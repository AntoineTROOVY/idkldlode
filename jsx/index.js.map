{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/aeft/math-utils.ts","../../../src/jsx/aeft/bezier.ts","../../../src/jsx/aeft/comp.ts","../../../src/jsx/aeft/keyframes.ts","../../../src/jsx/aeft/notifications.ts","../../../src/jsx/aeft/validation.ts","../../../src/jsx/aeft/elastic.ts","../../../src/js/utilities/bezier-utils.ts","../../../src/jsx/aeft/layers.ts","../../../src/jsx/aeft/bounce.ts","../../../src/jsx/aeft/licensing.ts","../../../src/jsx/aeft/convert-ease-bez.ts","../../../src/jsx/aeft/aeft.ts","../../../src/jsx/ilst/ilst.ts","../../../src/jsx/anim/anim.ts","../../../src/jsx/ppro/ppro.ts","../../../src/jsx/phxs/phxs.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n\tversion,\n\tid: \"com.curves.cep\",\n\tdisplayName: \"Curves\",\n\tsymlink: \"local\",\n\tport: 3000,\n\tservePort: 5000,\n\tstartingDebugPort: 8860,\n\textensionManifestVersion: 6.0,\n\trequiredRuntimeVersion: 9.0,\n\thosts: [\n\t\t{\n\t\t\tname: \"AEFT\",\n\t\t\tversion: \"[0.0,99.9]\",\n\t\t},\n\t],\n\n\ttype: \"Panel\",\n\ticonDarkNormal: \"./src/assets/light-icon.png\",\n\ticonNormal: \"./src/assets/dark-icon.png\",\n\ticonDarkNormalRollOver: \"./src/assets/light-icon.png\",\n\ticonNormalRollOver: \"./src/assets/dark-icon.png\",\n\t//@ts-ignore\n\tparameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\", \"--windowless-frame-rate=60\",\"--disable-frame-rate-limit\",\"--disable-gpu-vsync\",\"--disable-gpu\",\"--disable-gpu-compositing\",\"--hardware-acceleration=false\",\"--hardware-video-decode-framerate=0\",\"--enable-begin-frame-scheduling\" ],\n\twidth: 500,\n\theight: 550,\n\n\tpanels: [\n\t\t{\n\t\t\tmainPath: \"./main/index.html\",\n\t\t\tname: \"main\",\n\t\t\tpanelDisplayName: \"Curves\",\n\t\t\tautoVisible: true,\n\t\t\twidth: 600,\n\t\t\theight: 650,\n\t\t},\n\t\t{\n\t\t\tmainPath: \"./licensing/index.html\",\n\t\t\tname: \"licensing\",\n\t\t\ttype: \"Modeless\",\n\t\t\t// panelDisplayName: 'PP CEP Boilerplate | settings',\n\t\t\tautoVisible: true,\n\t\t\twidth: 400,\n\t\t\theight: 300,\n\t\t},\n\t],\n\tbuild: {\n\t\tjsxBin: \"copy\",\n\t\tsourceMap: true,\n\t},\n\tzxp: {\n\t\tcountry: \"US\",\n\t\tprovince: \"CA\",\n\t\torg: \"MyCompany\",\n\t\tpassword: \"mypassword\",\n\t\ttsa: \"http://timestamp.digicert.com/\",\n\t\tsourceMap: false,\n\t\tjsxBin: \"replace\",\n\t},\n\tinstallModules: [],\n\tcopyAssets: [],\n\tcopyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\nexport const ns = config.id;\n","//@ts-nocheck\n\n\n\n/**\n * Takes two arrays of numbers and returns a new array of tuples, where each tuple contains the corresponding elements from each array.\n * @param a An array of numbers\n * @param b An array of numbers\n * @returns An array of tuples, where each tuple contains the corresponding elements from `a` and `b`\n */\nexport const zip = (a: number[], b: number[]): [number, number][] => a.map((k, i) => [k, b[i]]);\n\n/**\n * Calculates the Euclidean distance between two points in n-dimensional space, where `n` is the length of the input arrays.\n * @param ogn An array of numbers representing the coordinates of the first point.\n * @param dst An array of numbers representing the coordinates of the second point.\n * @returns The Euclidean distance between the two points in n-dimensional space.\n */\nexport const getEuclideanDistance = (ogn: number[] | number, dst: number[] | number): number => {\n    if (Array.isArray(ogn) !== true) return Math.abs(ogn - dst);\n    let zipped: [number, number][] = zip(ogn, dst);\n    let summed: number = 0;\n    for (let i = 0; i < zipped.length; i++) {\n      let [x, y] = zipped[i];\n      summed += (y - x) ** 2;\n    }\n    return Math.sqrt(summed);\n  };\n\n\n\n/**\n * Returns the directional movement trend between two positions. For 1 dimensional movement,\n * the function is fed a float, and for 2 or 3 dimensional movement, the function is fed an array\n * of floats.\n *\n * @param curr The current position, represented as either a single float or an array of floats.\n * @param prev The previous position, represented as either a single float or an array of floats.\n * @returns An array representing the movement trend between the two positions, where 1 indicates\n *          an increase in value, -1 indicates a decrease in value, and 0 indicates no change.\n */\nexport const getVectorTrends = (curr: number[] | number, prev: number[] | number): number[] => {\n    let trend: number[] = [0, 0, 0];\n    if (typeof curr === \"number\" || typeof prev === \"number\") {\n        if (curr - prev > 0) {\n        return [1];\n        } else if (curr - prev < 0) {\n        return [-1];\n        } else {\n        return [0];\n        }\n    }\n    for (let i = 0; i < trend.length; i++) {\n        const currVal = parseFloat(curr[i].toFixed(10));\n        const prevVal = parseFloat(prev[i].toFixed(10));\n    \n        if (currVal > prevVal) {\n          trend[i] = 1;\n        } else if (currVal < prevVal) {\n          trend[i] = -1;\n        } else {\n          trend[i] = 0;\n        }\n      }\n    return trend\n}\n\nexport const degreesToRadians = (degrees) => {\n    return degrees * (Math.PI / 180);\n}\n\nexport const getDistanceBetweenPoints2D = (x1, y1, x2, y2) => {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\nexport function calculateIncomingVelocity(layerNum, time, prop): number {\n    if (!time || !layerNum) return 1; //TODO: we need to get a \"default\" layer number or value here for the UI? maybe do in UI\n    var delta = -0.03;\n    var v1 = prop.valueAtTime(time + delta, true);\n    var v2 = prop.valueAtTime(time + delta + delta, true);\n    var velocity = new Array(v1.length)\n    if(v1.length){\n        var i;\n        for(i=0;i<v1.length;i+=1){\n            velocity[i] = (v2[i] - v1[i])/delta;\n        }\n    } else {\n        velocity = (v2 - v1)/delta;\n    }\n    return velocity;\n}\n\nexport const normalize = (vec) => {\nreturn div(vec, length(vec));\n}\n\nfunction isInstanceOfArray(arr) {\nreturn arr.constructor === Array || arr.constructor === Float32Array;\n}\n\nfunction isNumerable(tOfV, v) {\nreturn tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;\n}\n\nfunction div(a,b) {\nlet tOfA = typeof a;\nlet tOfB = typeof b;\nlet arr;\nif(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n    return a / b;\n}\nlet i, len;\nif(isInstanceOfArray(a) && isNumerable(tOfB, b)){\n    len = a.length;\n    arr = new Array(len);\n    for(i=0;i<len;i+=1){\n        arr[i] = a[i] / b;\n    }\n    return arr;\n}\nif(isNumerable(tOfA, a) && isInstanceOfArray(b)){\n    len = b.length;\n    arr = new Array(len);\n    for(i=0;i<len;i+=1){\n        arr[i] = a / b[i];\n    }\n    return arr;\n}\nreturn 0;\n}\n\nexport const mapToValues = (val, multiplier) => {\n    if (val instanceof Array) {\n      let res = []\n      for (let i = 0; i < val.length; i++) {\n        res.push(val[i] * multiplier);\n      }\n      return res\n    } else {\n      return val * multiplier;\n    }\n  }\n  \nexport const addArrayValues = (val1, val2) => {\n    if (val1 instanceof Array) {\n      let res = []\n      for (let i = 0; i < val1.length; i++) {\n        res.push(val1[i] - val2[i]);\n      }\n      return res\n    } else {\n      return val1 - val2;\n    }\n  }","import { getDistanceBetweenPoints2D } from './math-utils';\n  /**\n   * Calculates and creates a AE keyframe ease object.\n   *\n   * @param prop - property in layer\n   * @param keyframeIndex - index of keyframe\n   * @param userVars - easing in cubic-bezier notation\n   * @returns an array of KeyframeEase objects\n   *\n   */\nexport const getBezierInEase = (prop: Property, keyframeIndex: number, userVars: [number, number, number, number]): KeyframeEase[] | undefined => {\n    let [ x1, y1, x2, y2 ] = userVars;\n    let priorVal = prop.keyValue(keyframeIndex - 1);\n    let priorTime = prop.keyTime(keyframeIndex - 1);\n    let selectedTime = prop.keyTime(keyframeIndex);\n    let selectedVal = prop.keyValue(keyframeIndex);\n    if (selectedVal instanceof Array == false && priorVal instanceof Array == false) {\n        let distanceBetweenPoints = Math.abs(priorVal - selectedVal);\n        let avSpeed = Math.abs(distanceBetweenPoints) / (priorTime - selectedTime);\n        let xEaseIn = 100 - x2 * 100;\n        let yEaseIn = .1 + (1 - y2) / (1 - x2) * avSpeed;\n        let easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n        //if the distance between the points is negative, we need to reverse the ease in and ease out\n        if (selectedVal > priorVal) {\n            yEaseIn *= -1;\n            easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n        }\n        return [easeIn];\n\n    } else if (prop.matchName.includes(\"Position\") || prop.matchName.includes(\"Color\") || prop.matchName.includes(\"Anchor\")) {\n        let distanceBetweenPoints = getDistanceBetweenPoints2D(priorVal[0], priorVal[1], selectedVal[0], selectedVal[1])\n        let avSpeed = Math.abs(distanceBetweenPoints) / (selectedTime - priorTime);\n        let inInf = 100 - x2 * 100;\n        let inSpd = (1 - y2) / (1 - x2) * avSpeed ;\n        let easeIn = getKeyframeEaseObject(inSpd, inInf);\n        return [easeIn]\n    } else if (selectedVal instanceof Array && priorVal instanceof Array) { \n            let easings = [];\n            let easeIn: KeyframeEase;\n            let easeOut\n            for (let i = 0; i < selectedVal.length; i++) {\n                let distanceBetweenPoints = Math.abs(priorVal[i] - selectedVal[i])\n                let avSpeed = Math.abs(distanceBetweenPoints) / (priorTime - selectedTime);\n                let xEaseOut = x1 * 100;\n                let yEaseOut = y1 / x1 * avSpeed;\n                let xEaseIn = 100 - x2 * 100;\n                let yEaseIn = .1 + (1 - y2) / (1 - x2) * avSpeed;\n                if (selectedVal[i] > priorVal[i]) {\n                    yEaseOut *= -1;\n                    yEaseIn *= -1;\n                    easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n                    easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n                } else {\n                    easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n                    easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n                }\n                easings.push([easeIn, easeOut]);     \n            }\n            if (prop.value.length == 1) {\n                //@ts-ignore\n                return [easeIn]\n            } else if (prop.value.length == 2) {\n                return [easings[0][1], easings[0][1]]\n            } else {\n                return [easings[0][0], easings[1][0], easings[2][0]];\n            }\n        }\n}\n\nfunction getKeyframeEaseObject(speed: number, influence: number) {\n    if (influence < 0.1) influence = 0.1;\n    if (influence > 100) influence = 100;\n    return new KeyframeEase(speed, influence);\n}\n\nexport const getBezierOutEase = (prop: Property, keyframeIndex: number, userVars: [number, number, number, number]) : KeyframeEase[] | undefined => {\n    let [ x1, y1, x2, y2 ] = userVars;\n    let postTime = prop.keyTime(keyframeIndex + 1);\n    let postVal = prop.keyValue(keyframeIndex + 1);\n    let selectedTime = prop.keyTime(keyframeIndex);\n    let selectedVal = prop.keyValue(keyframeIndex);\n    if (selectedVal instanceof Array == false && postVal instanceof Array == false) {\n        let distanceBetweenPoints = Math.abs(postVal - selectedVal);\n        let avSpeed = Math.abs(distanceBetweenPoints) / (postTime - selectedTime);\n        let xEaseOut = x1 * 100;\n        let yEaseOut = y1 / x1 * avSpeed;\n        let easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n        if (selectedVal > postVal) {\n            yEaseOut *= -1;\n            easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n        } \n        return [easeOut];\n        \n    } else if (prop.matchName.includes(\"Position\") || prop.matchName.includes(\"Color\") || prop.matchName.includes(\"Anchor\")) {\n\n        let distanceBetweenPoints = getDistanceBetweenPoints2D(postVal[0], postVal[1], selectedVal[0], selectedVal[1])\n        let avSpeed = Math.abs(distanceBetweenPoints) / (postTime - selectedTime);\n        let xEaseOut = x1 * 100;\n        let yEaseOut = y1 / x1 * avSpeed;\n        let easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n        return [easeOut]\n\n    } else if (selectedVal instanceof Array && postVal instanceof Array) { \n            let easings = [];\n            let easeIn\n            let easeOut: KeyframeEase\n            for (let i = 0; i < selectedVal.length; i++) {\n                let distanceBetweenPoints = Math.abs(postVal[i] - selectedVal[i])\n                let avSpeed = Math.abs(distanceBetweenPoints) / (postTime - selectedTime);\n                let xEaseOut = x1 * 100;\n                let yEaseOut = y1 / x1 * avSpeed;\n                let xEaseIn = 100 - x2 * 100;\n                let yEaseIn = .1 + (1 - y2) / (1 - x2) * avSpeed;\n                if (selectedVal[i] > postVal[i]) {\n                    yEaseOut *= -1;\n                    yEaseIn *= -1;\n                    easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n                    easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n                } else {\n                    easeIn = getKeyframeEaseObject(yEaseIn, xEaseIn);\n                    easeOut = getKeyframeEaseObject(yEaseOut, xEaseOut);\n                }\n                easings.push([easeIn, easeOut]);     \n            }\n            if (prop.value.length == 1) {\n                //@ts-ignore\n                return [easeIn]\n            } else if (prop.value.length == 2) {\n                return [easings[0][1], easings[0][1]]\n            } else {\n                return [easings[0][0], easings[1][0], easings[2][0]];\n            }\n        }\n}\n\n\nexport const applyBezierToPeak = (prop: Property, peakIdx: number, dstIdx: number, cubicBez:[number, number, number, number]): void => {\n        let inEase = getBezierInEase(prop, peakIdx + 1, [ cubicBez[0], cubicBez[1], 1 - cubicBez[0], 1 - cubicBez[1]]);    \n        let outEase = getBezierOutEase(prop, peakIdx - 1, [ cubicBez[0], cubicBez[1], 1 - cubicBez[0], 1 - cubicBez[1]]);\n        let mirroredPeakEase = getBezierInEase(prop, peakIdx, cubicBez);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(peakIdx, mirroredPeakEase, mirroredPeakEase);\n        let existingEase = prop.keyInTemporalEase(peakIdx - 1);\n        if (peakIdx - 1 !== dstIdx) prop.setTemporalContinuousAtKey(peakIdx - 1, false);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(peakIdx - 1, existingEase, outEase);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(peakIdx + 1, inEase)\n\n}\n\n\nexport const applyBezierToSingleSelection = (prop: Property, keyframeIndex: number, userVars: [number, number, number, number]): void => {\n    if(keyframeIndex === 1) {\n        let left = prop.selectedKeys[0]\n        let firstSelectedEaseInType = prop.keyInInterpolationType(left);\n        let outEase = getBezierOutEase(prop, left, userVars);\n        let originalEaseIn = prop.keyInTemporalEase(left);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(left, originalEaseIn, outEase);\n        if (firstSelectedEaseInType === KeyframeInterpolationType.LINEAR) {\n            prop.setInterpolationTypeAtKey(left, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER);\n        } else if (firstSelectedEaseInType === KeyframeInterpolationType.HOLD) {\n            prop.setInterpolationTypeAtKey(left, KeyframeInterpolationType.HOLD, KeyframeInterpolationType.BEZIER);\n        }\n    } else if (keyframeIndex === prop.numKeys) {\n        let right = prop.selectedKeys[0]\n        let lastSelectedEaseOutType = prop.keyOutInterpolationType(right);\n        let inEase = getBezierInEase(prop, right, userVars);\n        let originalEaseOut = prop.keyOutTemporalEase(right);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(right, inEase, originalEaseOut);\n    \n        if (lastSelectedEaseOutType === KeyframeInterpolationType.LINEAR) {\n            prop.setInterpolationTypeAtKey(right, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR);\n        } else if (lastSelectedEaseOutType === KeyframeInterpolationType.HOLD) {\n            prop.setInterpolationTypeAtKey(right, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.HOLD);\n        }\n    } else {\n        let outEase = getBezierOutEase(prop, keyframeIndex, [ userVars[0], userVars[1], 1 - userVars[0], 1 - userVars[1]]);\n        let inEase = getBezierInEase(prop, keyframeIndex, userVars);\n        //@ts-ignore\n        prop.setTemporalEaseAtKey(keyframeIndex, inEase, outEase);\n    }\n}\n\nexport const applyBezierToMultipleSelections = (prop: Property, selectedIndices: number[], userVars: [number, number, number, number]) => {\n    applyBezierBookends(prop, selectedIndices[0], selectedIndices[selectedIndices.length - 1], userVars)\n    for (let i = 1; i < selectedIndices.length - 1; i++) {\n        applyBezierToSingleSelection(prop, selectedIndices[i], userVars);\n    }\n}\n\n//for multiple selections far left and far right keyframe are only out and only in respectively\nexport const applyBezierBookends = (prop: Property, left: number, right: number, userVars: [number, number, number, number]) => {\n    let firstSelectedEaseInType = prop.keyInInterpolationType(left);\n    let outEase = getBezierOutEase(prop, left, [userVars[0], userVars[1], 1 - userVars[0], 1 - userVars[1] ]);\n    let originalEaseIn = prop.keyInTemporalEase(left);\n    //@ts-ignore\n    prop.setTemporalEaseAtKey(left, originalEaseIn, outEase);\n    let lastSelectedEaseOutType = prop.keyOutInterpolationType(right);\n    let inEase = getBezierInEase(prop, right, userVars);\n    let originalEaseOut = prop.keyOutTemporalEase(right);\n    //@ts-ignore\n    prop.setTemporalEaseAtKey(right, inEase, originalEaseOut);\n\n    if (lastSelectedEaseOutType === KeyframeInterpolationType.LINEAR) {\n        prop.setInterpolationTypeAtKey(right, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR);\n    } else if (lastSelectedEaseOutType === KeyframeInterpolationType.HOLD) {\n        prop.setInterpolationTypeAtKey(right, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.HOLD);\n    }\n    if (firstSelectedEaseInType === KeyframeInterpolationType.LINEAR) {\n        prop.setInterpolationTypeAtKey(left, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER);\n    } else if (firstSelectedEaseInType === KeyframeInterpolationType.HOLD) {\n        prop.setInterpolationTypeAtKey(left, KeyframeInterpolationType.HOLD, KeyframeInterpolationType.BEZIER);\n    }\n\n}","export const getActiveComposition = () => {\n    const comp = app.project && app.project.activeItem && app.project.activeItem instanceof CompItem ? app.project.activeItem : null\n    if (!comp) {\n      throw new Error('Please select a composition.')\n    }\n    return comp\n  }","//@ts-nocheck\n\nexport const getLatestSelectedKeyframeIndices = (prop: { selectedKeys: any; }) => {\n    let selectedIndices = prop.selectedKeys; \n    selectedIndices = selectedIndices.sort((a: number, b: number) => a - b);\n\n    return selectedIndices.slice(selectedIndices.length - 2, selectedIndices.length);\n}\nexport const clearSpatialOutEaseOnKeyframe = (prop, keyIndex) => {\n  if(prop.propertyValueType  == PropertyValueType.ThreeD_SPATIAL) {\n    let existingSpatialEaseIn = prop.keyInSpatialTangent(keyIndex)\n    !existingSpatialEaseIn ? existingSpatialEaseIn = [0, 0, 0] : null\n    prop.setSpatialTangentsAtKey(keyIndex, existingSpatialEaseIn, [0, 0, 0])\n  } else if (prop.propertyValueType  == PropertyValueType.TwoD_SPATIAL) {\n    let existingSpatialEaseIn = prop.keyInSpatialTangent(keyIndex)\n    !existingSpatialEaseIn ? existingSpatialEaseIn = [0, 0] : null\n    prop.setSpatialTangentsAtKey(keyIndex, existingSpatialEaseIn, [0, 0])\n  }\n}\n\nexport const clearAllSpatialEaseOnKeyframe = (prop, keyIndex) => {\n  if(prop.propertyValueType  == PropertyValueType.ThreeD_SPATIAL) {\n    prop.setSpatialTangentsAtKey(keyIndex, [0, 0, 0] , [0, 0, 0])\n  } else if (prop.propertyValueType  == PropertyValueType.TwoD_SPATIAL) {\n    prop.setSpatialTangentsAtKey(keyIndex, [0, 0] , [0, 0])\n  }\n}\n\nexport const getNearestFrameTime = (comp, newKeyframeTime) => {\n  const compStartTime = comp.displayStartTime;\n  const frameDuration = comp.frameDuration;\n  const elapsedTime = newKeyframeTime - compStartTime;\n  const nearestFrameIndex = Math.round(elapsedTime / frameDuration);\n  const nearestFrameTime = nearestFrameIndex * frameDuration + compStartTime;\n  return nearestFrameTime;\n}\n\n\n\nexport const createBounceKeyframe = (req) => {\n  \n  let { prop, newKeyframes } = req;\n  \n  for (let i = 0; i < newKeyframes.length; i++) {\n    let { time, value, index, hang, alternate } = newKeyframes[i];\n    prop.addKey(time);\n\n    if (value instanceof Array) {\n      value[2] = 0; //TODO: Handle 3D data\n    }\n\n    prop.setValueAtKey(index, value)\n    if (alternate) {\n      var easeIn = new KeyframeEase(0, hang); //set this 0 to 100.... for the hang var\n      var easeOut = new KeyframeEase(0, hang);\n      if (prop.matchName.includes('Scale')) {\n        prop.setTemporalEaseAtKey(index, [easeIn, easeIn, easeIn], [easeOut, easeOut, easeOut]);\n      } else {\n        prop.setTemporalEaseAtKey(index, [easeIn], [easeOut]);\n      }\n      prop.setInterpolationTypeAtKey(index, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER)\n    } else {\n      prop.setInterpolationTypeAtKey(index, KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.LINEAR)\n    }\n\n  }\n}\n\nexport const getKeyValues = (prop, keyToCopy) => {\n  const keyInInterpolationType = prop.keyInInterpolationType(keyToCopy)\n  const keyOutInterpolationType = prop.keyOutInterpolationType(keyToCopy)\n  const curKeyValue = prop.keyValue(keyToCopy)\n\n  let keyTemporalAutoBezier, keyTemporalContinuous\n  if (keyInInterpolationType === KeyframeInterpolationType.BEZIER && keyOutInterpolationType === KeyframeInterpolationType.BEZIER) {\n    keyTemporalAutoBezier = prop.keyTemporalAutoBezier(keyToCopy)\n    keyTemporalContinuous = prop.keyTemporalContinuous(keyToCopy)\n  }\n\n  let keyInTemporalEase, keyOutTemporalEase\n  if (keyOutInterpolationType !== KeyframeInterpolationType.HOLD) {\n    keyInTemporalEase = prop.keyInTemporalEase(keyToCopy)\n    keyOutTemporalEase = prop.keyOutTemporalEase(keyToCopy)\n  }\n\n  let keySpatialAutoBezier, keySpatialContinuous, keyInSpatialTangent, keyOutSpatialTangent, keyRoving\n  if (\n    prop.propertyValueType === PropertyValueType.TwoD_SPATIAL ||\n    prop.propertyValueType === PropertyValueType.ThreeD_SPATIAL\n  ) {\n    keySpatialAutoBezier = prop.keySpatialAutoBezier(keyToCopy)\n    keySpatialContinuous = prop.keySpatialContinuous(keyToCopy)\n    keyInSpatialTangent = prop.keyInSpatialTangent(keyToCopy)\n    keyOutSpatialTangent = prop.keyOutSpatialTangent(keyToCopy)\n    keyRoving = prop.keyRoving(keyToCopy)\n  }\n\n  return { keyInInterpolationType, keyOutInterpolationType, curKeyValue, keyTemporalAutoBezier, \n    keyTemporalContinuous, keyInTemporalEase, keyOutTemporalEase,\n    keySpatialAutoBezier, keySpatialContinuous, keyInSpatialTangent, keyOutSpatialTangent, keyRoving }\n}\n\nexport const setKeyValues = (prop, newKeyIndex, keyframe) => {\n  prop.setValueAtKey(newKeyIndex, keyframe.curKeyValue)\n  if (keyframe.keyOutInterpolationType !== KeyframeInterpolationType.HOLD)\n    prop.setTemporalEaseAtKey(newKeyIndex, keyframe.keyInTemporalEase, keyframe.keyOutTemporalEase)\n    prop.setInterpolationTypeAtKey(newKeyIndex, keyframe.keyInInterpolationType, keyframe.keyOutInterpolationType)\n\n  if (\n    keyframe.keyInInterpolationType === KeyframeInterpolationType.BEZIER &&\n    keyframe.keyOutInterpolationType === KeyframeInterpolationType.BEZIER &&\n    keyframe.keyTemporalContinuous\n  ) {\n    prop.setTemporalContinuousAtKey(newKeyIndex, keyframe.keyTemporalContinuous)\n    prop.setTemporalAutoBezierAtKey(newKeyIndex, keyframe.keyTemporalAutoBezier)\n  }\n\n  if (\n    prop.propertyValueType === PropertyValueType.TwoD_SPATIAL ||\n    prop.propertyValueType === PropertyValueType.ThreeD_SPATIAL\n  ) {\n    prop.setSpatialContinuousAtKey(newKeyIndex, keyframe.keySpatialContinuous)\n    prop.setSpatialAutoBezierAtKey(newKeyIndex, keyframe.keySpatialAutoBezier)\n    prop.setSpatialTangentsAtKey(newKeyIndex, keyframe.keyInSpatialTangent, keyframe.keyOutSpatialTangent)\n    if (keyframe.keyRoving) prop.setRovingAtKey(newKeyIndex, keyframe.keyRoving)\n  }\n}  \n  \nexport const collectKeyframes = (propertyInput) => {\n      if(propertyInput instanceof Property){\n          var totalKeys, prop, keyIndexList, curKeyIndex, curKeyValue, inIn, outIn, ab, cb, ie, oe, sab, scb, ist, ost, rov, twoDS, threeDS;\n          twoDS = PropertyValueType.TwoD_SPATIAL;\n          threeDS = PropertyValueType.ThreeD_SPATIAL;\n          keyIndexList = new Array();\n          totalKeys = propertyInput.numKeys;\n          \n          //If the property has at least 1 keyframe, proceed\n          if(totalKeys > 0){\n              //Loop through keys\n              for(var i = 1; i <= totalKeys; i++){\n                  //Get the current key time...\n                  curKeyTime = propertyInput.keyTime(i);\n                  //...it's index...\n                  curKeyIndex = i;\n                  //...and it's value\n                  curKeyValue = propertyInput.keyValue(i);\n                  \n                  //Get the key in and out interpolation types\n                  inIn = propertyInput.keyInInterpolationType(curKeyIndex);\n                  outIn = propertyInput.keyOutInterpolationType(curKeyIndex);\n                  \n                  //Get the key Temporal Continuous and Auto Bezier if the key type is BEZIER\n                  if(inIn == KeyframeInterpolationType.BEZIER && outIn == KeyframeInterpolationType.BEZIER){\n                      ab = propertyInput.keyTemporalAutoBezier(curKeyIndex);\n                      cb = propertyInput.keyTemporalContinuous(curKeyIndex);\n                  }\n              \n                  //Get it's Temporal ease if it is not a HOLD key type\n                  if(inIn != KeyframeInterpolationType.HOLD || outIn != KeyframeInterpolationType.HOLD){\n                      ie = propertyInput.keyInTemporalEase(curKeyIndex);\n                      oe = propertyInput.keyOutTemporalEase(curKeyIndex);\n                  }\n              \n                  //Get the key Spatial Continuous, Auto Bezier, Tangents, and Roving values if the key type is 2D or 3D SPATIAL\n                  if(propertyInput.propertyValueType == twoDS || propertyInput.propertyValueType == threeDS){\n                      sab = propertyInput.keySpatialAutoBezier(curKeyIndex);\n                      scb = propertyInput.keySpatialContinuous(curKeyIndex);\n                      ist = propertyInput.keyInSpatialTangent(curKeyIndex);\n                      ost = propertyInput.keyOutSpatialTangent(curKeyIndex);\n                      rov = propertyInput.keyRoving(curKeyIndex);\n                  }\n                  \n                  //Assemble that collected key data into and object array for retrieval later\n                  keyIndexList[keyIndexList.length] = {\n                      'curKeyTime':curKeyTime, \n                      'curKeyIndex':curKeyIndex, \n                      'curKeyValue':curKeyValue, \n                      'keyInInterpolationType':inIn, \n                      'keyOutInterpolationType':outIn, \n                      'keyTemporalAutoBezier':ab, \n                      'keyTemporalContinuous':cb, \n                      'keyInTemporalEase':ie, \n                      'keyOutTemporalEase':oe, \n                      'keySpatialAutoBezier':sab, \n                      'keySpatialContinuous':scb, \n                      'keyInSpatialTangent':ist, \n                      'keyOutSpatialTangent':ost, \n                      'keyRoving':rov\n                      }\n              }\n              //Return the object array as a result\n              return keyIndexList;\n          }else{\n              //If there were no keyframes, then just return null as a result\n              return null;\n          }\n      }\n}\n\n\n\nexport const collectKeyframesInRange = (propertyInput, startIndex, endIndex) => {\n  if(propertyInput instanceof Property){\n      var totalKeys, prop, keyIndexList, curKeyIndex, curKeyValue, inIn, outIn, ab, cb, ie, oe, sab, scb, ist, ost, rov, twoDS, threeDS;\n      twoDS = PropertyValueType.TwoD_SPATIAL;\n      threeDS = PropertyValueType.ThreeD_SPATIAL;\n      keyIndexList = new Array();\n      totalKeys = propertyInput.numKeys;\n      \n      //If the property has at least 1 keyframe, proceed\n      if(totalKeys > 0){\n          //Loop through keys\n          for(var i = startIndex; i <= endIndex; i++){\n              //Get the current key time...\n              curKeyTime = propertyInput.keyTime(i);\n              //...it's index...\n              curKeyIndex = i;\n              //...and it's value\n              curKeyValue = propertyInput.keyValue(i);\n              \n              //Get the key in and out interpolation types\n              inIn = propertyInput.keyInInterpolationType(curKeyIndex);\n              outIn = propertyInput.keyOutInterpolationType(curKeyIndex);\n              \n              //Get the key Temporal Continuous and Auto Bezier if the key type is BEZIER\n              if(inIn == KeyframeInterpolationType.BEZIER && outIn == KeyframeInterpolationType.BEZIER){\n                  ab = propertyInput.keyTemporalAutoBezier(curKeyIndex);\n                  cb = propertyInput.keyTemporalContinuous(curKeyIndex);\n              }\n          \n              //Get it's Temporal ease if it is not a HOLD key type\n              if(inIn != KeyframeInterpolationType.HOLD || outIn != KeyframeInterpolationType.HOLD){\n                  ie = propertyInput.keyInTemporalEase(curKeyIndex);\n                  oe = propertyInput.keyOutTemporalEase(curKeyIndex);\n              }\n          \n              //Get the key Spatial Continuous, Auto Bezier, Tangents, and Roving values if the key type is 2D or 3D SPATIAL\n              if(propertyInput.propertyValueType == twoDS || propertyInput.propertyValueType == threeDS){\n                  sab = propertyInput.keySpatialAutoBezier(curKeyIndex);\n                  scb = propertyInput.keySpatialContinuous(curKeyIndex);\n                  ist = propertyInput.keyInSpatialTangent(curKeyIndex);\n                  ost = propertyInput.keyOutSpatialTangent(curKeyIndex);\n                  rov = propertyInput.keyRoving(curKeyIndex);\n              }\n              \n              //Assemble that collected key data into and object array for retrieval later\n              keyIndexList[keyIndexList.length] = {\n                  'curKeyTime':curKeyTime, \n                  'curKeyIndex':curKeyIndex, \n                  'curKeyValue':curKeyValue, \n                  'inIn':inIn, \n                  'outIn':outIn, \n                  'ab':ab, \n                  'cb':cb, \n                  'ie':ie, \n                  'oe':oe, \n                  'sab':sab, \n                  'scb':scb, \n                  'ist':ist, \n                  'ost':ost, \n                  'rov':rov\n                  }\n          }\n          //Return the object array as a result\n          return keyIndexList;\n      }else{\n          //If there were no keyframes, then just return null as a result\n          return null;\n      }\n  }\n}\n\nexport const shiftKeyToNewOffset = (prop, keyToCopy, offset, keyToRemove) => {\n  if (offset === 0) return\n  const value = getKeyValues(prop, keyToCopy)\n  const newTime = prop.keyTime(keyToCopy) + offset\n  const newKeyIndex = prop.addKey(newTime)\n  setKeyValues(prop, newKeyIndex, value)\n  prop.removeKey(keyToRemove)\n}\n\nconst scootAllPropGroupKeys = (propGroup, offset) => {\n  // Iterate over the specified property group's properties.\n  for (let i = 1; i <= propGroup.numProperties; i++) {\n    const prop = propGroup.property(i)\n    if (prop.propertyType === PropertyType.PROPERTY) {\n      if (prop.matchName === \"ADBE Marker\") continue\n      if (!prop.isTimeVarying) continue\n\n      if (offset > 0) {\n        for (let j = prop.numKeys; j >= 1; j--)\n          shiftKeyToNewOffset(prop, j, offset, j)\n      } else {\n        for (let j = 1; j <= prop.numKeys; j++)\n          shiftKeyToNewOffset(prop, j, offset, j + 1)\n      }\n    } else if (prop.propertyType === PropertyType.INDEXED_GROUP) {\n      scootAllPropGroupKeys(prop, offset)\n    } else if (prop.propertyType === PropertyType.NAMED_GROUP) {\n      scootAllPropGroupKeys(prop, offset)\n    }\n  }\n}\n\nconst getNestedSelectedProperties = (propGroup) => {\n  let props = []\n  for (let i = 1; i <= propGroup.numProperties; i++) {\n    const prop = propGroup.property(i)\n    if (prop && prop.propertyType) {\n      if (prop.propertyType === PropertyType.PROPERTY) {\n        if (prop.matchName === 'ADBE Marker') continue\n        if (!prop.isTimeVarying) continue\n        if (!prop.selectedKeys || prop.selectedKeys.length <= 0) continue\n        props.push(prop)\n      } else if (prop.propertyType === PropertyType.INDEXED_GROUP && prop.property) {\n        props = props.concat(getNestedSelectedProperties(prop))\n      } else if (prop.propertyType === PropertyType.NAMED_GROUP && prop.property) {\n        props = props.concat(getNestedSelectedProperties(prop))\n      }\n    }\n  }\n\n  return props\n}\n\nconst getSelectedProperties = (comp) => {\n  if (!PropertyType || !PropertyType.PROPERTY)\n    throw new Error('PropertyType seems invalid. This may be because of another extension!')\n  return (comp.selectedProperties || [])\n    .filter(Boolean)\n    .reduce((props, selectedProp) => {\n      if (selectedProp.propertyType === PropertyType.PROPERTY) {\n        if (\n          selectedProp.matchName !== 'ADBE Marker' &&\n          selectedProp.isTimeVarying &&\n          selectedProp.selectedKeys && selectedProp.selectedKeys.length > 0\n        ) {\n          return [...props, selectedProp]\n        }\n      } else if (\n        (selectedProp.propertyType === PropertyType.INDEXED_GROUP ||\n        selectedProp.propertyType === PropertyType.NAMED_GROUP) &&\n        selectedProp.numProperties\n      ) {\n        return props.concat(getNestedSelectedProperties(selectedProp))\n      } else {\n        return props\n      }\n    }, [])\n}","\nexport const notify = {\n    noComp: \"General Input Validation: Please select a composition.\",\n    noLayer: \"General Input Validation: Please select a layer.\",\n    noKeyframes: \"Property with 0 selected keyframes found.\",\n    insufficientLayers: \"Please select 2 or more layers.\",\n    pleaseAddOneOrMoreKeyframes: \"Please add one or more keyframes to the selected property.\",\n    pleaseSelectOneOrMoreKeyframes: \"Please select one or more keyframes across two or more layers or properties.\",\n    elasticNoDelta: \"Penultimate and final keyframe share static values.\",\n    maskPath: \"Mask paths are not yet supported.\"\n}","import { clearAllSpatialEaseOnKeyframe } from \"./keyframes\";\nimport { notify } from \"./notifications\";\n\nexport const generalInputValidation = (\n\tcomp: any,\n\tselectedLayers: string | any[]\n) => {\n\tif (!comp) {\n\t\talert(notify.noComp);\n\t\treturn;\n\t}\n\tif (selectedLayers.length === 0) {\n\t\talert(notify.noLayer);\n\t\treturn;\n\t}\n};\n\n/**\n * Takes a keyframeable property in Adobe After Effects and returns an array of indices for the selected keyframes.\n *\n * @param prop - The keyframeable property to validate.\n * @returns An array of indices for the selected keyframes, or an empty array if the selected keyframes are invalid.\n */\nexport const validateSelectedKeyframes = (prop: any) => {\n\tlet selectedKeys = prop.selectedKeys;\n\tif (!selectedKeys || selectedKeys.length < 1 || prop.numKeys < 1) {\n\t\t//alert(notify.noKeyframes)\n\t\treturn [];\n\t}\n\tlet originIndex = selectedKeys[selectedKeys.length - 2];\n\tlet destinationIndex = selectedKeys[selectedKeys.length - 1];\n\n\tif (prop.matchName.includes(\"Mask Path\")) {\n\t\t//alert(notify.maskPath)\n\t\treturn [];\n\t} else if (selectedKeys.length === 1) {\n\t\t// alert(notify.elasticNoDelta);\n\t\treturn selectedKeys;\n\t} else {\n\t\tif (\n\t\t\tprop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ||\n\t\t\tprop.propertyValueType == PropertyValueType.TwoD_SPATIAL\n\t\t) {\n\t\t\tclearAllSpatialEaseOnKeyframe(prop, originIndex);\n\t\t\tclearAllSpatialEaseOnKeyframe(prop, destinationIndex);\n\t\t}\n\t\treturn selectedKeys;\n\t}\n};\n\nexport const validateSelectedKeyframesDistribute = (prop: any) => {\n\tlet selectedKeys = prop.selectedKeys;\n\tif (!selectedKeys || selectedKeys.length <= 1 || prop.numKeys < 2) {\n\t\t//alert(notify.noKeyframes)\n\t\treturn [];\n\t}\n\tlet originIndex = selectedKeys[selectedKeys.length - 2];\n\tlet destinationIndex = selectedKeys[selectedKeys.length - 1];\n\n\tif (prop.matchName.includes(\"Mask Path\")) {\n\t\t//alert(notify.maskPath)\n\t\treturn [];\n\t} else if (prop.keyValue(destinationIndex) === prop.keyValue(originIndex)) {\n\t\t//alert(notify.elasticNoDelta)\n\t\treturn [];\n\t} else {\n\t\treturn selectedKeys;\n\t}\n};\n\n//TODO: 0 breaks AE, check for more details and fix below.\nexport const validateCubicBezierX = (vals: number[]) => {\n\tif (vals[0] >= 1) vals[0] = 0.999;\n\tif (vals[2] >= 1) vals[2] = 0.999;\n\tif (vals[0] < 0.001) vals[0] = 0.001;\n\tif (vals[2] < 0.001) vals[2] = 0.001;\n\treturn vals;\n};\n\nexport const elasticKeyframeValidation = (prop: any) => {\n\tlet selectedIndices = prop.selectedKeys;\n\tif (!selectedIndices || selectedIndices.length <= 1 || prop.numKeys < 2) {\n\t\t//alert(`${notify.noKeyframes} Found at: ${prop.name}`)\n\t\treturn [];\n\t}\n\tvar originIndex = selectedIndices[selectedIndices.length - 2];\n\tvar destinationIndex = selectedIndices[selectedIndices.length - 1];\n\tif (prop.keyValue(destinationIndex) === prop.keyValue(originIndex)) {\n\t\t//alert(`${notify.elasticNoDelta} Found at: ${prop.name}`)\n\t\treturn [];\n\t}\n\tif (selectedIndices[selectedIndices.length - 1]) return selectedIndices;\n};\n","//@ts-nocheck\nimport {\n\tclearAllSpatialEaseOnKeyframe,\n\tgetNearestFrameTime,\n\tsetKeyValues,\n} from \"./keyframes\";\nimport { mapToValues, addArrayValues } from \"./math-utils\";\nimport { applyBezierToPeak, getBezierInEase, getBezierOutEase } from \"./bezier\";\nimport { validateCubicBezierX } from \"./validation\";\nimport { getLatestSelectedKeyframeIndices } from \"./keyframes\";\n\nexport const elasticEaseLayer = (prop, req, selectedIndices) => {\n\tlet values = req.values;\n\tlet ognIdx = selectedIndices[selectedIndices.length - 2];\n\tlet dstIdx = selectedIndices[selectedIndices.length - 1];\n\tlet timeDelta = prop.keyTime(dstIdx) - prop.keyTime(ognIdx);\n\tlet timeLerpMax = timeDelta * 5; //TODO: magic number here corresponds to UI visualization as initial bounce occurs at 1/5 of total time\n\tlet valueLerpMax = prop.keyValue(dstIdx) - prop.keyValue(ognIdx);\n\n\tlet keysframesToWrite = [];\n\n\tfor (let i = 0; i < values.length - 1; i += 2) {\n\t\t//get time offset of peak keyframe\n\t\tlet peakKfTimeOffset = values[i].dstLerpX * timeLerpMax;\n\t\t//get time offset of destination keyframe\n\t\tlet dstKfTimeOffset = values[i + 1].dstLerpX * timeLerpMax;\n\t\t//get value offset of peak keyframe\n\t\tlet peakKfValueOffset = mapToValues(valueLerpMax, values[i].dstLerpY);\n\t\t//get value offset of destination keyframe\n\t\tlet dstKfValueOffset = mapToValues(valueLerpMax, values[i + 1].dstLerpY);\n\t\t//get peak keyframe total value\n\t\tlet peakKfValue =\n\t\t\taddArrayValues(prop.keyValue(dstIdx), peakKfValueOffset) +\n\t\t\tvalueLerpMax / 2;\n\t\t//get destination keyframe total value\n\t\tlet dstKfValue =\n\t\t\taddArrayValues(prop.keyValue(dstIdx), dstKfValueOffset) +\n\t\t\tvalueLerpMax / 2;\n\n\t\t//TODO: validation functions for values\n\t\tif (prop.matchName.includes(\"Opacity\")) {\n\t\t\tif (peakKfValue > 100) {\n\t\t\t\tpeakKfValue = 100;\n\t\t\t} else if (dstKfValue < 0) {\n\t\t\t\tdstKfValue = 0;\n\t\t\t}\n\t\t}\n\n\t\t//validate easing\n\t\tlet cubicBez = validateCubicBezierX([\n\t\t\t1 - values[i].ognXCubic,\n\t\t\t1 - values[i].ognYCubic,\n\t\t\tvalues[i].dstXCubic,\n\t\t\tvalues[i].dstYCubic,\n\t\t]);\n\t\tlet kf = {\n\t\t\tpeakKfTimeOffset,\n\t\t\tdstKfTimeOffset,\n\t\t\tpeakKfValue,\n\t\t\tdstKfValue,\n\t\t\tcubicBez,\n\t\t};\n\t\tkeysframesToWrite.push(kf);\n\t}\n\treturn keysframesToWrite;\n};\n\n//req object is being passed existing keyframes\nexport const createElasticKeyframesStop = (\n\treq,\n\tcomp,\n\tprop,\n\tselectedIndices,\n\tnewKeyframes\n) => {\n\t//find first existing keyframe after startTime\n\tlet firstExistingKeyframeTime = Infinity;\n\tlet finalSelectedKeyframeTime = prop.keyTime(\n\t\tselectedIndices[selectedIndices.length - 1]\n\t);\n\tlet ognSelectedKeyframeTime = prop.keyTime(\n\t\tselectedIndices[selectedIndices.length - 2]\n\t);\n\t//get first existing keyframe AFTER last selected index\n\tfor (let i = 1; i <= prop.numKeys; i++) {\n\t\tlet curKeyTime = prop.keyTime(i);\n\t\tif (curKeyTime > finalSelectedKeyframeTime) {\n\t\t\tfirstExistingKeyframeTime = curKeyTime;\n\t\t\t//TODO: look into potential issues with removing continuous easing on existing keyframes\n\t\t\tif (\n\t\t\t\tprop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ||\n\t\t\t\tprop.propertyValueType == PropertyValueType.TwoD_SPATIAL\n\t\t\t) {\n\t\t\t\tclearAllSpatialEaseOnKeyframe(prop, i);\n\t\t\t\tif (i + 1 <= prop.numKeys) clearAllSpatialEaseOnKeyframe(prop, i + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let i = 0; i < newKeyframes.length; i++) {\n\t\tlet {\n\t\t\tpeakKfTimeOffset,\n\t\t\tdstKfTimeOffset,\n\t\t\tpeakKfValue,\n\t\t\tdstKfValue,\n\t\t\tcubicBez,\n\t\t} = newKeyframes[i];\n\n\t\tlet peakKeyframeWriteTime = ognSelectedKeyframeTime + peakKfTimeOffset;\n\t\tlet dstKeyframeWriteTime = ognSelectedKeyframeTime + dstKfTimeOffset;\n\t\tif (req.config.keyframeWriteAtTimeBehavior === \"nearest_frame\") {\n\t\t\tpeakKeyframeWriteTime = getNearestFrameTime(comp, peakKeyframeWriteTime);\n\t\t\tdstKeyframeWriteTime = getNearestFrameTime(comp, dstKeyframeWriteTime);\n\t\t\tif (peakKeyframeWriteTime === dstKeyframeWriteTime) return;\n\t\t}\n\n\t\tif (dstKeyframeWriteTime < firstExistingKeyframeTime) {\n\t\t\t//create peak keyframe\n\t\t\tlet newPeakKf = prop.addKey(peakKeyframeWriteTime);\n\t\t\t//set peak keyframe value\n\t\t\tprop.setValueAtKey(newPeakKf, peakKfValue);\n\t\t\t//create destination keyframe\n\t\t\tlet newDestKf = prop.addKey(dstKeyframeWriteTime);\n\t\t\t//set destination keyframe value\n\t\t\tprop.setValueAtKey(newDestKf, dstKfValue);\n\t\t\t//handle preexisting incoming ease on final selected keyframe\n\t\t\tif (i === 0) {\n\t\t\t\tlet mirroredPeakEase = getBezierInEase(prop, newPeakKf, cubicBez);\n\t\t\t\tprop.setTemporalEaseAtKey(\n\t\t\t\t\tnewPeakKf,\n\t\t\t\t\tmirroredPeakEase,\n\t\t\t\t\tmirroredPeakEase\n\t\t\t\t);\n\t\t\t\tlet existingEaseIn = prop.keyInTemporalEase(newPeakKf - 1);\n\t\t\t\tlet existingEaseOut = prop.keyOutTemporalEase(newPeakKf - 1);\n\t\t\t\tprop.setTemporalContinuousAtKey(newPeakKf - 1, false);\n\t\t\t\tprop.setTemporalEaseAtKey(\n\t\t\t\t\tnewPeakKf - 1,\n\t\t\t\t\texistingEaseIn,\n\t\t\t\t\texistingEaseOut\n\t\t\t\t);\n\t\t\t\tprop.setTemporalEaseAtKey(newPeakKf + 1, mirroredPeakEase);\n\t\t\t} else {\n\t\t\t\tapplyBezierToPeak(\n\t\t\t\t\tprop,\n\t\t\t\t\tnewPeakKf,\n\t\t\t\t\tselectedIndices[selectedIndices.length - 1],\n\t\t\t\t\tcubicBez\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tprop.removeKey(selectedIndices[selectedIndices.length - 1]);\n};\n\nexport const createElasticKeyframesOverwrite = (\n\treq,\n\tcomp,\n\tprop,\n\tselectedIndices,\n\tnewKeyframes\n) => {\n\tlet finalSelectedKeyframeTime = prop.keyTime(\n\t\tselectedIndices[selectedIndices.length - 1]\n\t);\n\tlet finalKeyframeWriteTime =\n\t\tnewKeyframes[newKeyframes.length - 1].dstKfTimeOffset +\n\t\tfinalSelectedKeyframeTime;\n\tlet ognSelectedKeyframeTime = prop.keyTime(\n\t\tselectedIndices[selectedIndices.length - 2]\n\t);\n\n\tfor (let i = prop.numKeys; i > 0; i--) {\n\t\tif (\n\t\t\tprop.keyTime(i) < finalKeyframeWriteTime &&\n\t\t\tprop.keyTime(i) > finalSelectedKeyframeTime\n\t\t) {\n\t\t\tprop.removeKey(i);\n\t\t}\n\t}\n\n\tfor (let i = 0; i < newKeyframes.length; i++) {\n\t\tlet {\n\t\t\tpeakKfTimeOffset,\n\t\t\tdstKfTimeOffset,\n\t\t\tpeakKfValue,\n\t\t\tdstKfValue,\n\t\t\tcubicBez,\n\t\t} = newKeyframes[i];\n\n\t\tlet peakKeyframeWriteTime = ognSelectedKeyframeTime + peakKfTimeOffset;\n\t\tlet dstKeyframeWriteTime = ognSelectedKeyframeTime + dstKfTimeOffset;\n\t\tif (req.config.keyframeWriteAtTimeBehavior === \"nearest_frame\") {\n\t\t\tpeakKeyframeWriteTime = getNearestFrameTime(comp, peakKeyframeWriteTime);\n\t\t\tdstKeyframeWriteTime = getNearestFrameTime(comp, dstKeyframeWriteTime);\n\t\t\tif (peakKeyframeWriteTime === dstKeyframeWriteTime) return;\n\t\t}\n\n\t\tlet newPeakKf = prop.addKey(peakKeyframeWriteTime);\n\t\t//set peak keyframe value\n\t\tprop.setValueAtKey(newPeakKf, peakKfValue);\n\t\t//create destination keyframe\n\t\tlet newDestKf = prop.addKey(dstKeyframeWriteTime);\n\t\t//set destination keyframe value\n\t\tprop.setValueAtKey(newDestKf, dstKfValue);\n\t\t//handle preexisting incoming ease on final selected keyframe\n\t\tif (i === 0) {\n\t\t\tlet mirroredPeakEase = getBezierInEase(prop, newPeakKf, cubicBez);\n\t\t\tprop.setTemporalEaseAtKey(newPeakKf, mirroredPeakEase, mirroredPeakEase);\n\t\t\tlet existingEaseIn = prop.keyInTemporalEase(newPeakKf - 1);\n\t\t\tlet existingEaseOut = prop.keyOutTemporalEase(newPeakKf - 1);\n\t\t\tprop.setTemporalContinuousAtKey(newPeakKf - 1, false);\n\t\t\tprop.setTemporalEaseAtKey(newPeakKf - 1, existingEaseIn, existingEaseOut);\n\t\t\tprop.setTemporalEaseAtKey(newPeakKf + 1, mirroredPeakEase);\n\t\t} else {\n\t\t\tapplyBezierToPeak(\n\t\t\t\tprop,\n\t\t\t\tnewPeakKf,\n\t\t\t\tselectedIndices[selectedIndices.length - 1],\n\t\t\t\tcubicBez\n\t\t\t);\n\t\t}\n\t}\n\tprop.removeKey(selectedIndices[selectedIndices.length - 1]);\n};\n","export const rangeMap = (a: number[], b: number[]) => (s: number) => {\n  const [a1, a2] = a;\n  const [b1, b2] = b;\n  // Scaling up an order, and then down, to bypass a potential,\n  // precision issue with negative numbers.\n  return (((((b2 - b1) * (s - a1)) / (a2 - a1)) * 10) + (10 * b1)) / 10;\n};\n\n//@ts-ignore\nexport const enumFromTo = (m, n) => {\n  const arr = [];\n  for (let i = m; i <= n; i++) {\n    arr.push(i);\n  }\n  return arr;\n}\n\nexport const mapEasing = (f: any, xs: any[]) => mapPolyfill(xs, f);\n\nexport const mapPolyfill = (arr: any[], fn: any) => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(fn(arr[i], i));\n  }\n  return result;\n};\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\nconst NEWTON_ITERATIONS = 4\nconst NEWTON_MIN_SLOPE = 0.001\nconst SUBDIVISION_PRECISION = 0.0000001\nconst SUBDIVISION_MAX_ITERATIONS = 10\nconst kSplineTableSize = 11\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0)\n\nconst A = (aA1: number, aA2: number) => 1.0 - 3.0 * aA2 + 3.0 * aA1\nconst B = (aA1: number, aA2: number) => 3.0 * aA2 - 6.0 * aA1\nconst C = (aA1: number) => 3.0 * aA1\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (aT: number, aA1: number, aA2: number) => {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nconst getSlope = (aT: number, aA1: number, aA2: number) => {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)\n}\n\nconst binarySubdivide = (aX: number, aA: number, aB: number, mX1: number, mX2: number) => {\n  let currentX,\n    currentT,\n    i = 0\n  do {\n    currentT = aA + (aB - aA) / 2.0\n    currentX = calcBezier(currentT, mX1, mX2) - aX\n    if (currentX > 0.0) {\n      aB = currentT\n    } else {\n      aA = currentT\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)\n  return currentT\n}\n\nconst newtonRaphsonIterate = (aX: number, aGuessT: number, mX1: number, mX2: number) => {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2)\n    if (currentSlope === 0.0) {\n      return aGuessT\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX\n    aGuessT -= currentX / currentSlope\n  }\n  return aGuessT\n}\n\nconst LinearEasing = (x: number) => {\n  return x\n}\n\nexport const bezier = (mX1: number, mY1: number, mX2: number, mY2: number) => {\n  // if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n  //   throw new Error('bezier x values must be in [0, 1] range')\n  // }\n  if (mX1 >= 1) mX1 = 1;\n  if (mX2 >= 1) mX2 = 1;\n  if (mX1 < .001) mX1 = .001;\n  if (mX2 < .001) mX2 = .001;\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing\n  }\n\n  // Precompute samples table\n  const sampleValues = new Array(kSplineTableSize)\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)\n  }\n\n  const getTForX = (aX: number) => {\n    let intervalStart = 0.0\n    let currentSample = 1\n    let lastSample = kSplineTableSize - 1\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize\n    }\n    --currentSample\n\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample])\n    const guessForT = intervalStart + dist * kSampleStepSize\n\n    const initialSlope = getSlope(guessForT, mX1, mX2)\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2)\n    } else if (initialSlope === 0.0) {\n      return guessForT\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)\n    }\n  }\n\n  return (x: number) => {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x\n    }\n    return calcBezier(getTForX(x), mY1, mY2)\n  }\n}","//TODO: typings\nexport function getSelectedLayerTimes() {\n    const activeComposition = app.project && app.project.activeItem && app.project.activeItem instanceof CompItem ? app.project.activeItem : null\n    const selectedLayerTimes: object[] = []\n    if (activeComposition && <[]>activeComposition?.selectedLayers) {\n        for (let i = 0; i < activeComposition.selectedLayers.length; i++) {\n            let obj = { index: 0, time: 0, frameRate: 0}\n            obj.index = activeComposition.selectedLayers[i].index\n            obj.time = activeComposition.selectedLayers[i].inPoint\n            obj.frameRate = activeComposition.frameRate\n            selectedLayerTimes.push(obj)\n        }\n    }\n    return selectedLayerTimes\n}\n//AE layers are 1-indexed\n//User selected layer array is 0 indexed and can contain any contiguous range of layers  \nexport function moveLayers(req: any, sortedLayerArr: any) {\n    var myComp = app.project.activeItem;\n    if (myComp) {\n        for (var i = 0; i < sortedLayerArr.length; i++) {\n            //@ts-ignore\n            myComp.layer(sortedLayerArr[i].index).startTime = req[i] * myComp.frameDuration;\n        }\n    }\n}\n\nexport function getSelectedLayers() {\n    var activeComposition = app.project && app.project.activeItem && app.project.activeItem instanceof CompItem ? app.project.activeItem : null;\n    let active = activeComposition?.selectedLayers;\n    return active\n}\n  ","//@ts-nocheck\nimport { getLatestSelectedKeyframeIndices, clearAllSpatialEaseOnKeyframe, getNearestFrameTime } from './keyframes';\nimport { applyBezierToPeak } from './bezier';\nimport { mapToValues, addArrayValues } from './math-utils';\nimport { validateCubicBezierX } from './validation';\n\nconst getValueDelta = (ogn, dst) => {\n  if (ogn instanceof Array) {\n    let res = []\n    for (let i = 0; i < ogn.length; i++) {\n      res.push(dst[i] - ogn[i]);\n    }\n    return res;\n  } else {\n    return Math.abs(dst - ogn);\n  }\n}\n\nexport const bounceEaseLayer = (req, comp, prop, values) => {\n  let selectedIndices = getLatestSelectedKeyframeIndices(prop);\n  let ognIdx = selectedIndices[selectedIndices.length - 2];\n  let dstIdx = selectedIndices[selectedIndices.length - 1];\n  let timeDelta = prop.keyTime(dstIdx) - prop.keyTime(ognIdx);\n  let timeLerpMax = timeDelta * 5; //TODO: magic number here corresponds to UI visualization as initial bounce occurs at 1/5 of total time\n  let currOgn = ognIdx\n  let valueLerpMax = prop.keyValue(dstIdx) - prop.keyValue(ognIdx);\n  //TODO: validation functions for values\n  if (prop.matchName.includes('Opacity')) {\n    if (valueLerpMax > 100) {\n      valueLerpMax = 100;\n    }\n  }\n  let keysframesToWrite = [];\n  for (let i = 0; i < values.length; i++) {\n    let peakDeltaLerp = ((values[i].dstLerpX - values[i].ognLerpX) / 2) + values[i].ognLerpX;\n    let peakKfTimeOffset = peakDeltaLerp * timeLerpMax;\n    let peakKfValue = mapToValues(valueLerpMax, values[i].peakLerpY); // SHOULD BE THIS PLUS DST VAL\n    peakKfValue = addArrayValues(prop.keyValue(dstIdx), peakKfValue);\n    // let peakKf = prop.addKey(peakKfTime);\n    // prop.setValueAtKey(peakKf, peakKfValue);\n    let dstLerp = values[i].dstLerpX;\n    let dstKfTimeOffset = dstLerp * timeLerpMax;\n    // currOgn = prop.addKey(destKfTime);\n    // prop.setValueAtKey(currOgn, prop.keyValue(dstIdx));\n    let cubicBez = validateCubicBezierX([values[i].mirrorPeakXCubic, values[i].mirrorPeakYCubic, values[i].dstXCubic, values[i].dstYCubic])\n    let keyframe = {\n      peakKfTimeOffset,\n      peakKfValue,\n      dstKfValue: prop.keyValue(dstIdx),\n      dstKfTimeOffset,\n      cubicBez\n    }\n    keysframesToWrite.push(keyframe);\n    // if(prop.propertyValueType  == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType  == PropertyValueType.TwoD_SPATIAL) {\n    //   clearSpatialOutEaseOnKeyframe(prop, peakKf - 1)\n    // }\n    // applyBezierToPeak(prop, peakKf, dstIdx, cubicBezVal);\n  }\n  return keysframesToWrite;\n};\n\nexport const createBounceKeyframesOverwrite = (req, comp, prop, selectedIndices, newKeyframes) => {\n  let finalSelectedKeyframeTime = prop.keyTime(selectedIndices[selectedIndices.length - 1]);\n  let ognSelectedKeyframeTime = prop.keyTime(selectedIndices[selectedIndices.length - 2]);\n  let finalKeyframeWriteTime = newKeyframes[newKeyframes.length - 1].dstKfTimeOffset + finalSelectedKeyframeTime;\n  \n  for (let i = prop.numKeys; i > 0; i--) {\n    if (prop.keyTime(i) < finalKeyframeWriteTime && prop.keyTime(i) > finalSelectedKeyframeTime) {\n      prop.removeKey(i);\n    }\n  }\n\n  for (let i = 0; i < newKeyframes.length; i++) {\n    let { peakKfTimeOffset,\n      dstKfTimeOffset,\n      peakKfValue,\n      dstKfValue,\n      cubicBez,} = newKeyframes[i]\n      let peakKeyframeWriteTime = ognSelectedKeyframeTime + peakKfTimeOffset;\n      let dstKeyframeWriteTime = ognSelectedKeyframeTime + dstKfTimeOffset;\n      if (req.config.keyframeWriteAtTimeBehavior === 'nearest_frame') \n      {\n        peakKeyframeWriteTime = getNearestFrameTime(comp, peakKeyframeWriteTime); \n        dstKeyframeWriteTime = getNearestFrameTime(comp, dstKeyframeWriteTime);\n        if (peakKeyframeWriteTime === dstKeyframeWriteTime) return\n      }\n      //create peak keyframe\n      let newPeakKf = prop.addKey(peakKeyframeWriteTime);\n      //set peak keyframe value\n      prop.setValueAtKey(newPeakKf, peakKfValue);\n      //create destination keyframe\n      let newDstKf = prop.addKey(dstKeyframeWriteTime);\n      //set destination keyframe value\n      prop.setValueAtKey(newDstKf, dstKfValue);\n      applyBezierToPeak(prop, newPeakKf, selectedIndices[selectedIndices.length - 1], cubicBez);\n  }\n}\n\nexport const createBounceKeyframesStop = (req, comp, prop, selectedIndices, newKeyframes) => {\n  let firstExistingKeyframeTime = Infinity\n  let finalSelectedKeyframeTime = prop.keyTime(selectedIndices[selectedIndices.length - 1]);\n  let ognSelectedKeyframeTime = prop.keyTime(selectedIndices[selectedIndices.length - 2]);\n\n  for (let i = 1; i <= prop.numKeys; i++) {\n    let curKeyTime = prop.keyTime(i)\n    if (curKeyTime > finalSelectedKeyframeTime) {\n        firstExistingKeyframeTime = curKeyTime;\n        //TODO: look into potential issues with removing continuous easing on existing keyframes\n        if(prop.propertyValueType  == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType  == PropertyValueType.TwoD_SPATIAL) {\n          clearAllSpatialEaseOnKeyframe(prop, i)\n          if (i + 1 <= prop.numKeys) clearAllSpatialEaseOnKeyframe(prop, i + 1)\n        }\n        break;\n    }\n  }\n\n  for (let i = 0; i < newKeyframes.length; i++) {\n    let { peakKfTimeOffset,\n      dstKfTimeOffset,\n      peakKfValue,\n      dstKfValue,\n      cubicBez,} = newKeyframes[i]\n\n      let peakKeyframeWriteTime = ognSelectedKeyframeTime + peakKfTimeOffset;\n      let dstKeyframeWriteTime = ognSelectedKeyframeTime + dstKfTimeOffset;\n      if (req.config.keyframeWriteAtTimeBehavior === 'nearest_frame') \n      {\n        peakKeyframeWriteTime = getNearestFrameTime(comp, peakKeyframeWriteTime); \n        dstKeyframeWriteTime = getNearestFrameTime(comp, dstKeyframeWriteTime);\n        if (peakKeyframeWriteTime === dstKeyframeWriteTime) return\n      }\n\n      if (dstKeyframeWriteTime < firstExistingKeyframeTime) {\n        //create peak keyframe\n        let newPeakKf = prop.addKey(peakKeyframeWriteTime);\n        //set peak keyframe value\n        prop.setValueAtKey(newPeakKf, peakKfValue);\n        //create destination keyframe\n        let newDstKf = prop.addKey(dstKeyframeWriteTime);\n        //set destination keyframe value\n        prop.setValueAtKey(newDstKf, dstKfValue);\n        applyBezierToPeak(prop, newPeakKf, selectedIndices[selectedIndices.length - 1], cubicBez);\n    }\n  }\n}\n\n//TODO: consider using this to create mode allowing user to specific angle and velocity of bounce\n// var basicBounceEaseLayer = function basicBounceEaseLayer(prop, layerNum) {\n//     var a = collectKeyframes(prop);\n//     var incomingVal = a[a.length - 1]['curKeyValue'];\n//     elev = degreesToRadians(75);\n//     v = 1900;\n//     e = .7;\n//     f = .5;\n//     gravity = 5000;\n//     maxBounces = 11;\n//     tLaunch = .5;\n//     vy = v*Math.sin(elev);\n//     vx = v*Math.cos(elev);\n//     var numKeys = 2;\n//     for (var i = 0; i < 3; i += .01) {\n//       if (i >= tLaunch){\n//         t = i - tLaunch;\n//         tCur = 0;\n//         segDur = 2*vy/g;\n//         tNext = segDur;\n//         d = 0; // x distance traveled\n//         nb = 0; // number of bounces\n//         while (tNext < t && nb <= maxBounces){\n//           d += vx*segDur;\n//           vy *= e;\n//           vx *= f;\n//           segDur *= e;\n//           tCur = tNext;\n//           tNext += segDur;\n//           nb++\n//         }\n//         if(nb <= maxBounces){\n//           delta = t - tCur;\n//           x = d + delta*vx;\n//           y = delta*(vy - g*delta/2);\n//         }else{\n//           x = d;\n//           y = 0;\n//         }\n//         numKeys++\n//         var newKeyframePosition = [incomingVal[0] + x, incomingVal[1] + (-y), incomingVal[2] + 0];\n//         createKeyframe(prop, numKeys, i, newKeyframePosition);\n//       }else\n//         0\n//     }\n//   }","export const retrieveLocalLicense = (): string => {\n\tconst hasLicense = app.settings.haveSetting(\"pp-prefs\", \"key\");\n\tlet License = <LicenseType>{\n\t\tkey: \"null\",\n\t\tplan: \"null\",\n\t\tlast_check: 0,\n\t};\n\n\tif (!hasLicense) {\n\t\tconst jsonLicense = JSON.stringify(License);\n\t\treturn jsonLicense;\n\t}\n\n\tconst key = app.settings.getSetting(\"pp-prefs\", \"key\");\n\tconst plan = app.settings.getSetting(\"pp-prefs\", \"plan\");\n\tconst last_check = parseInt(\n\t\tapp.settings.getSetting(\"pp-prefs\", \"last_check\")\n\t);\n\tLicense = { key, plan, last_check };\n\tconst jsonLicense = JSON.stringify(License);\n\treturn jsonLicense;\n};\n\nexport const updateLicense = (License: LicenseType) => {\n\tsaveSetting(\"last_check\", License.last_check.toString());\n\tsaveSetting(\"plan\", License.plan);\n\tsaveSetting(\"key\", License.key);\n\tapp.preferences.saveToDisk();\n};\n\nfunction saveSetting(setting: string, value: string) {\n\tapp.settings.saveSetting(\"pp-prefs\", setting, value);\n\tapp.preferences.saveToDisk();\n}\n","//@ts-nocheck\n\nexport function convertToBezierValues(property, indexTime){\n\n    var i, len;\n    var key = {};\n    var lastKey = {};\n    var interpolationType = '';\n    key.time = property.keyTime(indexTime+1);\n    lastKey.time = property.keyTime(indexTime);\n    key.value = getPropertyValue(property.keyValue(indexTime+1), false);\n    lastKey.value = getPropertyValue(property.keyValue(indexTime), false);\n    if(!(key.value instanceof Array)){\n        key.value = [key.value];\n        lastKey.value = [lastKey.value];\n    }\n    if(property.keyOutInterpolationType(indexTime) == KeyframeInterpolationType.HOLD){\n        interpolationType = 'hold';\n    }else{\n        if(property.keyOutInterpolationType(indexTime) == KeyframeInterpolationType.LINEAR && property.keyInInterpolationType(indexTime + 1) == KeyframeInterpolationType.LINEAR){\n            interpolationType = 'linear';\n        }\n        buildKeyInfluence(property, key, lastKey, indexTime);\n        switch(property.propertyValueType){\n            case PropertyValueType.ThreeD_SPATIAL:\n            case PropertyValueType.TwoD_SPATIAL:\n                lastKey.to = property.keyOutSpatialTangent(indexTime);\n                key.ti = property.keyInSpatialTangent(indexTime+1);\n                break;\n        }\n    }\n    if(interpolationType == 'hold'){\n        //what is easing for hold type\n    }\n    duration = key.time - lastKey.time;\n    len = key.value.length;\n    bezierIn = {};\n    bezierOut = {};\n    averageSpeed = 0;\n    var infOut,infIn;\n    switch(property.propertyValueType){\n        case PropertyValueType.ThreeD_SPATIAL:\n        case PropertyValueType.TwoD_SPATIAL:\n            var curveLength = getCurveLength(lastKey.value,key.value, lastKey.to, key.ti);\n            averageSpeed = curveLength/duration;\n            if(curveLength === 0){\n                infOut = lastKey.easeOut.influence;\n                infIn = key.easeIn.influence;\n            }else{\n                infOut = Math.min(100*curveLength/(lastKey.easeOut.speed*duration), lastKey.easeOut.influence);\n                infIn = Math.min(100*curveLength/(key.easeIn.speed*duration), key.easeIn.influence);\n            }\n            bezierIn.x = 1 - infIn / 100;\n            bezierOut.x = infOut / 100;\n            break;\n        case PropertyValueType.SHAPE:\n            averageSpeed = 1;\n            infOut = Math.min(100/lastKey.easeOut.speed, lastKey.easeOut.influence);\n            infIn = Math.min(100/key.easeIn.speed, key.easeIn.influence);\n            bezierIn.x = 1 - infIn / 100;\n            bezierOut.x = infOut / 100;\n            break;\n        case PropertyValueType.ThreeD:\n        case PropertyValueType.TwoD:\n        case PropertyValueType.OneD:\n        case PropertyValueType.COLOR:\n            bezierIn.x = [];\n            bezierOut.x = [];\n            key.easeIn.forEach(function(item, index){\n                bezierIn.x[index] = 1 - item.influence / 100;\n                bezierOut.x[index] = lastKey.easeOut[index].influence / 100;\n\n            });\n            averageSpeed = [];\n            for(i=0;i<len;i+=1){\n                averageSpeed[i] =  (key.value[i] - lastKey.value[i])/duration;\n            }\n            break;\n    }\n    if(averageSpeed == 0){\n        bezierIn.y = bezierIn.x;\n        bezierOut.y = bezierOut.x;\n    }else{\n        switch(property.propertyValueType){\n            case PropertyValueType.ThreeD_SPATIAL:\n            case PropertyValueType.TwoD_SPATIAL:\n            case PropertyValueType.SHAPE:\n                if(interpolationType == 'linear'){\n                    bezierIn.y = bezierIn.x;\n                    bezierOut.y = bezierOut.x;\n                }else{\n                    bezierIn.y =  1 - ((key.easeIn.speed) / averageSpeed) * (infIn / 100);\n                    bezierOut.y = ((lastKey.easeOut.speed) / averageSpeed) * bezierOut.x;\n                }\n                break;\n            case PropertyValueType.ThreeD:\n            case PropertyValueType.TwoD:\n            case PropertyValueType.OneD:\n            case PropertyValueType.COLOR:\n                bezierIn.y = [];\n                bezierOut.y = [];\n                key.easeIn.forEach(function(item,index){\n                    if(averageSpeed[index] == 0 || interpolationType == 'linear'){\n                        bezierIn.y[index] = bezierIn.x[index];\n                        bezierOut.y[index] = bezierOut.x[index];\n                    }else{\n                        bezierIn.y[index] = 1 - ((item.speed) / averageSpeed[index]) * (item.influence / 100);\n                        bezierOut.y[index] = ((lastKey.easeOut[index].speed) / averageSpeed[index]) * bezierOut.x[index];\n                    }\n                });\n            }\n    }\n    return {in:bezierOut,out:bezierIn, duration:duration};\n}\n\nfunction getCurveLength(initPos,endPos, outBezier, inBezier){\n    var k, curveSegments = 200;\n    var point,lastPoint = null;\n    var ptDistance;\n    var absToCoord,absTiCoord;\n    var triCoord1,triCoord2,triCoord3,liCoord1,liCoord2,ptCoord,perc,addedLength = 0;\n    for(k=0;k<curveSegments;k+=1){\n        point = [];\n        perc = k/(curveSegments-1);\n        ptDistance = 0;\n        absToCoord = [];\n        absTiCoord = [];\n        outBezier.forEach(function(item,index){\n            if(absToCoord[index] == null){\n                absToCoord[index] = initPos[index] + outBezier[index];\n                absTiCoord[index] = endPos[index] + inBezier[index];\n            }\n            triCoord1 = initPos[index] + (absToCoord[index] - initPos[index])*perc;\n            triCoord2 = absToCoord[index] + (absTiCoord[index] - absToCoord[index])*perc;\n            triCoord3 = absTiCoord[index] + (endPos[index] - absTiCoord[index])*perc;\n            liCoord1 = triCoord1 + (triCoord2 - triCoord1)*perc;\n            liCoord2 = triCoord2 + (triCoord3 - triCoord2)*perc;\n            ptCoord = liCoord1 + (liCoord2 - liCoord1)*perc;\n            point.push(ptCoord);\n            if(lastPoint !== null){\n                ptDistance += Math.pow(point[index] - lastPoint[index],2);\n            }\n        });\n        ptDistance = Math.sqrt(ptDistance);\n        addedLength += ptDistance;\n        lastPoint = point;\n    }\n    return addedLength;\n}\n\n\nfunction buildKeyInfluence(property, key, lastKey, indexTime){\n    switch(property.propertyValueType){\n        case PropertyValueType.ThreeD_SPATIAL:\n        case PropertyValueType.TwoD_SPATIAL:\n        case PropertyValueType.SHAPE:\n            key.easeIn = {\n                influence : property.keyInTemporalEase(indexTime+1)[0].influence,\n                speed : property.keyInTemporalEase(indexTime+1)[0].speed\n            };\n            lastKey.easeOut = {\n                influence : property.keyOutTemporalEase(indexTime)[0].influence,\n                speed : property.keyOutTemporalEase(indexTime)[0].speed\n            };\n            break;\n        default:\n            key.easeIn = [];\n            lastKey.easeOut = [];\n            var inEase = property.keyInTemporalEase(indexTime+1);\n            var outEase = property.keyOutTemporalEase(indexTime);\n            inEase.forEach(function(item,index){\n                key.easeIn.push({influence : item.influence, speed:item.speed});\n                lastKey.easeOut.push({influence : outEase[index].influence, speed:outEase[index].speed});\n            });\n    }\n}\n\nfunction getPropertyValue(value,type){\n    switch(type)\n    {\n        case 'color':\n            return rgbToHex(Math.round(values[0]*255),Math.round(values[1]*255),Math.round(values[2]*255));\n            break;\n        default:\n            return value;\n            break;\n    }\n}\n\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function(callback, thisArg) {\n        var T, k;\n        if (this == null) {\n            throw new TypeError(' this is null or not defined');\n        }\n        var O = Object(this);\n        var len = O.length >>> 0;\n        if (typeof callback !== \"function\") {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        k = 0;\n        while (k < len) {\n            var kValue;\n            if (k in O) {\n                kValue = O[k];\n                callback.call(T, kValue, k, O);\n            }\n            k++;\n        }\n    };\n}\nif (!Array.prototype.map) {\n    Array.prototype.map = function(callback, thisArg) {\n\n        var T, A, k;\n\n        if (this == null) {\n            throw new TypeError(' this is null or not defined');\n        }\n        var O = Object(this);\n        var len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        A = new Array(len);\n        k = 0;\n        while (k < len) {\n            var kValue, mappedValue;\n            if (k in O) {\n                kValue = O[k];\n                mappedValue = callback.call(T, kValue, k, O);\n                A[k] = mappedValue;\n            }\n            k++;\n        }\n\n        return A;\n    };\n}","// @ts-nocheck\nimport {\n\tapplyBezierBookends,\n\tapplyBezierToSingleSelection,\n\tapplyBezierToMultipleSelections,\n} from \"./bezier\";\nimport { getActiveComposition } from \"./comp\";\nimport { elasticEaseLayer } from \"./elastic\";\nimport { shiftKeyToNewOffset } from \"./keyframes\";\nimport {\n\tcreateElasticKeyframesOverwrite,\n\tcreateElasticKeyframesStop,\n} from \"./elastic\";\nimport {\n\tbezier,\n\trangeMap,\n\tenumFromTo,\n\tmapEasing,\n} from \"../../js/utilities/bezier-utils\";\nimport { getSelectedLayers, getSelectedLayerTimes } from \"./layers\";\nimport {\n\tgeneralInputValidation,\n\tvalidateSelectedKeyframes,\n\tvalidateCubicBezierX,\n\tvalidateSelectedKeyframesDistribute,\n} from \"./validation\";\nimport { moveLayers } from \"./layers\";\nimport { notify } from \"./notifications\";\nimport { ToolApplyRequest, PresetObj } from \"../../js/types/general-types\";\nimport {\n\tbounceEaseLayer,\n\tcreateBounceKeyframesStop,\n\tcreateBounceKeyframesOverwrite,\n} from \"./bounce\";\nimport { mapPolyfill } from \"../../js/utilities/bezier-utils\";\nimport { retrieveLocalLicense, updateLicense } from \"./licensing\";\nimport { convertToBezierValues } from \"./convert-ease-bez\";\n\nexport { retrieveLocalLicense, updateLicense };\n\nexport const applyToolES = (req: ToolApplyRequest) => {\n\tlet resObj: ESresObjType = {\n\t\tsuccess: true,\n\t\tdata: null,\n\t\tmessage: \"\",\n\t};\n\tlet comp = getActiveComposition();\n\tlet layers = getSelectedLayers();\n\tlet noActiveItemMessage: string = \"\";\n\tif (req.tool === \"distribute\")\n\t\tnoActiveItemMessage =\n\t\t\t\"Please select keyframes or layers to apply the distribute to.\";\n\tif (req.tool === \"synergy\")\n\t\tnoActiveItemMessage = \"Please select keyframes to apply the synergy to.\";\n\tif (req.tool === \"bezier\")\n\t\tnoActiveItemMessage = \"Please select keyframes to apply the bezier to.\";\n\tif (req.tool === \"elastic\")\n\t\tnoActiveItemMessage = \"Please select keyframes to apply the elastic to.\";\n\tif (req.tool === \"bounce\")\n\t\tnoActiveItemMessage = \"Please select keyframes to apply the bounce to.\";\n\tif (!comp || !layers?.length > 0)\n\t\treturn JSON.stringify({\n\t\t\tsuccess: false,\n\t\t\tdata: {},\n\t\t\tmessage: noActiveItemMessage,\n\t\t});\n\tgeneralInputValidation(comp, layers);\n\n\tswitch (req.tool) {\n\t\tcase \"bezier\":\n\t\t\tresObj = bezierEase(req, comp, layers, resObj);\n\t\t\tbreak;\n\t\tcase \"elastic\":\n\t\t\tresObj = elasticEase(req, comp, layers, resObj);\n\t\t\tbreak;\n\t\tcase \"bounce\":\n\t\t\tresObj = bounceEase(req, comp, layers, resObj);\n\t\t\tbreak;\n\t\tcase \"distribute\":\n\t\t\tresObj = distributeEase(req, comp, layers, resObj);\n\t\t\tbreak;\n\t\tcase \"synergy\":\n\t\t\tresObj = synergyDistributeAndEase(req, comp, layers, resObj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn JSON.stringify(resObj);\n};\n\nexport const clearKeyframeEasing = () => {\n\tapp.beginUndoGroup(\"clear keyframe easing\");\n\tlet comp = getActiveComposition();\n\tlet layers = getSelectedLayers();\n\tif (!comp || !layers?.length > 0) return;\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar layerPropArray: _PropertyClasses[] = comp.layer(\n\t\t\tlayers[i][\"index\"]\n\t\t).selectedProperties;\n\t\tfor (let j = 0; j < layerPropArray.length; j++) {\n\t\t\tlet prop = layerPropArray[j] as Property<UnknownPropertyType>;\n\t\t\tif (prop instanceof PropertyGroup || prop instanceof MaskPropertyGroup)\n\t\t\t\tcontinue;\n\t\t\tlet selectedKeys = prop.selectedKeys;\n\t\t\tfor (let k = 0; k < selectedKeys.length; k++) {\n\t\t\t\tprop.setInterpolationTypeAtKey(\n\t\t\t\t\tselectedKeys[k],\n\t\t\t\t\tKeyframeInterpolationType.LINEAR,\n\t\t\t\t\tKeyframeInterpolationType.LINEAR\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tapp.endUndoGroup();\n};\n\nexport const readKeyframePairEasing = () => {\n\tlet comp = getActiveComposition();\n\tlet layers = getSelectedLayers();\n\t//search all selected layers for keyframes\n\t//if there are only 2 selected keyframes on a single layer, return the easing of those keyframes\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar layerPropArray: _PropertyClasses[] = comp.layer(\n\t\t\tlayers[i][\"index\"]\n\t\t).selectedProperties;\n\t\tfor (let j = 0; j < layerPropArray.length; j++) {\n\t\t\tlet prop = layerPropArray[j] as Property<UnknownPropertyType>;\n\t\t\tif (prop instanceof PropertyGroup || prop instanceof MaskPropertyGroup)\n\t\t\t\tcontinue;\n\t\t\tlet selectedKeys = prop.selectedKeys;\n\t\t\tif (\n\t\t\t\tselectedKeys.length === 2 &&\n\t\t\t\tselectedKeys[0] === selectedKeys[1] - 1\n\t\t\t) {\n\t\t\t\tlet converted = convertToBezierValues(prop, selectedKeys[0]);\n\t\t\t\tconverted.success = true;\n\t\t\t\treturn JSON.stringify(converted);\n\t\t\t} else if (\n\t\t\t\tselectedKeys.length === 2 &&\n\t\t\t\tselectedKeys[0] !== selectedKeys[1] - 1\n\t\t\t) {\n\t\t\t\tlet easeOut = convertToBezierValues(prop, selectedKeys[0]);\n\t\t\t\tlet easeIn = convertToBezierValues(prop, selectedKeys[1] - 1);\n\t\t\t\tlet res = {\n\t\t\t\t\tin: { x: easeOut[\"in\"][\"x\"], y: easeOut[\"in\"][\"y\"] },\n\t\t\t\t\tout: { x: easeIn[\"out\"][\"x\"], y: easeIn[\"out\"][\"y\"] },\n\t\t\t\t\tduration: false,\n\t\t\t\t\tsuccess: true,\n\t\t\t\t};\n\t\t\t\treturn JSON.stringify(res);\n\t\t\t} else if (\n\t\t\t\tselectedKeys.length === 1 &&\n\t\t\t\tselectedKeys[0] !== 1 &&\n\t\t\t\tselectedKeys[0] !== prop.numKeys\n\t\t\t) {\n\t\t\t\tlet easeOut = convertToBezierValues(prop, selectedKeys[0] - 1);\n\t\t\t\tlet easeIn = convertToBezierValues(prop, selectedKeys[0]);\n\t\t\t\tlet res = {\n\t\t\t\t\tin: { x: easeIn[\"in\"][\"x\"], y: easeIn[\"in\"][\"y\"] },\n\t\t\t\t\tout: { x: easeOut[\"out\"][\"x\"], y: easeOut[\"out\"][\"y\"] },\n\t\t\t\t\tduration: false,\n\t\t\t\t\tsuccess: true,\n\t\t\t\t};\n\t\t\t\treturn JSON.stringify(res);\n\t\t\t}\n\t\t}\n\t}\n\treturn JSON.stringify({\n\t\tsuccess: false,\n\t\tdata: {},\n\t\tmessage: \"Please select 2 keys in order to read their values.\",\n\t});\n};\n\nexport function saveCustomPresets(value: PresetObj[]) {\n\tapp.preferences.savePrefAsString(\"presets\", \"custom\", JSON.stringify(value));\n\tapp.preferences.saveToDisk();\n\tapp.preferences.reload();\n\treturn value;\n}\n\nexport function loadCustomPresets(): string | undefined {\n\tconst hasCustomPresets = app.preferences.havePref(\"presets\", \"custom\")\n\tif (!hasCustomPresets) {\n\t\treturn \"[]\";\n\t} else {\n\t\tconst presetEasings = app.preferences.getPrefAsString(\"presets\", \"custom\")\n\t\treturn presetEasings;\n\t}\n}\n\nexport function savePresetOrdering(value: string[], tool: string) {\n\tapp.preferences.savePrefAsString(\n\t\t\"presets\",\n\t\t`${tool}_presets_ordering`,\n\t\tJSON.stringify(value)\n\t);\n\tapp.preferences.saveToDisk();\n\tapp.preferences.reload();\n\treturn value;\n}\n\nexport function loadPresetOrdering(tool: string): string {\n\tconst hasOrdering = app.preferences.havePref(\n\t\t\"presets\",\n\t\t`${tool}_presets_ordering`\n\t);\n\tif (!hasOrdering) {\n\t\treturn \"[]\";\n\t} else {\n\t\tconst ordering = app.preferences.getPrefAsString(\n\t\t\t\"presets\",\n\t\t\t`${tool}_presets_ordering`\n\t\t);\n\t\treturn ordering;\n\t}\n}\n\nexport function saveFavoritePresets(value: string) {\n\tapp.preferences.savePrefAsString(\n\t\t\"presets\",\n\t\t\"favorites\",\n\t\tJSON.stringify(value)\n\t);\n\tapp.preferences.saveToDisk();\n\tapp.preferences.reload();\n\treturn value;\n}\n\nexport function loadFavoritePresets(): string | undefined {\n\tconst hasFavoritePresets = app.preferences.havePref(\"presets\", \"favorites\");\n\tif (!hasFavoritePresets) {\n\t\treturn \"{}\";\n\t} else {\n\t\tconst favoritePresets = app.preferences.getPrefAsString(\n\t\t\t\"presets\",\n\t\t\t\"favorites\"\n\t\t);\n\t\treturn favoritePresets;\n\t}\n}\n\nfunction synergyDistributeAndEase(req: ToolApplyRequest, comp: CompItem, layers: Layer[], resObj: ESResObjType) {\n\tlet noKeyframesNotification = false;\n\tlet keyframePairArr = [];\n\tlet earliestFoundKeyframe = Infinity;\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar layerPropArray: _PropertyClasses[] = comp.layer(layers[i]['index']).selectedProperties\n\t\tif (layers[i].matchName === \"ADBE Vector Layer\") {\n\t\t\tlayerPropArray = sortShapesInShapeLayer(layerPropArray)\n\t\t} else {\n\t\t\tlayerPropArray = layerPropArray.sort((a, b) => { return a.propertyIndex - b.propertyIndex })\n\t\t}\n\t\tfor (let j = 0; j < layerPropArray.length; j++) {\n\t\t\tlet currProperty = layerPropArray[j] as Property<UnknownPropertyType>;\n\t\t\tif (currProperty instanceof PropertyGroup || currProperty instanceof MaskPropertyGroup) continue;\n\t\t\tlet selectedKeyframes = validateSelectedKeyframes(layerPropArray[j]);\n\t\t\tif (!selectedKeyframes.length) {\n\t\t\t\tif (!noKeyframesNotification) {\n\t\t\t\t\t// alert(notify.noKeyframes);\n\t\t\t\t\t// resObj = { success: false, data: null, message: notify.noKeyframes }\n\t\t\t\t\tnoKeyframesNotification = true;\n\t\t\t\t}\n\t\t\t} else if (selectedKeyframes.length >= 2) {\n\t\t\t\tif (currProperty.keyTime(selectedKeyframes[0]) < earliestFoundKeyframe) earliestFoundKeyframe = currProperty.keyTime(selectedKeyframes[0]);\n\t\t\t\tkeyframePairArr.push({\n\t\t\t\t\tproperty: currProperty,\n\t\t\t\t\tinIndex: selectedKeyframes[selectedKeyframes.length - 2],\n\t\t\t\t\toutIndex: selectedKeyframes[selectedKeyframes.length - 1]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\tlet inEase = validateCubicBezierX(req.userVars.inEase);\n\tlet outEase = validateCubicBezierX(req.userVars.outEase);\n\tlet deltasArr = [];\n\tfor (let i = 0; i < 4; i++) {\n\t\tdeltasArr[i] = inEase[i] - outEase[i];\n\t}\n\tlet deltaIncrement = [];\n\tfor (let i = 0; i < 4; i++) {\n\t\tdeltaIncrement[i] = deltasArr[i] / keyframePairArr.length;\n\t}\n\tlet values = validateCubicBezierX(req.values);\n\t//@ts-ignore\n\tconst easing = bezier(values[0], values[1], values[2], values[3]);\n\tconst mapping = rangeMap([1, keyframePairArr.length], [0, 1])\n\tconst layersArr = enumFromTo(1, keyframePairArr.length)\n\tlet rangeMappedLayers = mapEasing(mapping, layersArr)\n\tlet updatedStartTimes: number[] = []\n\tfor (var i = 0; i < rangeMappedLayers.length; i++) {\n\t\tupdatedStartTimes[i] = easing(rangeMappedLayers[i]) * req.userVars.numFrames;\n\t}\n\tif (req.userVars.isInverted) updatedStartTimes = updatedStartTimes.reverse();\n\n\tapp.beginUndoGroup(\"Lazy Layers\");\n\tfor (let i = 0; i < keyframePairArr.length; i++) {\n\t\tapplyBezierBookends(\n\t\t\tkeyframePairArr[i].property,\n\t\t\tkeyframePairArr[i].inIndex,\n\t\t\tkeyframePairArr[i].outIndex,\n\t\t\tvalidateCubicBezierX(req.userVars.outEase)\n\t\t);\n\t\tshiftKeyToNewOffset(\n\t\t\tkeyframePairArr[i].property,\n\t\t\tkeyframePairArr[i].outIndex,\n\t\t\tupdatedStartTimes[i] * comp.frameDuration,\n\t\t\tkeyframePairArr[i].outIndex\n\t\t);\n\t\tshiftKeyToNewOffset(\n\t\t\tkeyframePairArr[i].property,\n\t\t\tkeyframePairArr[i].inIndex,\n\t\t\tupdatedStartTimes[i] * comp.frameDuration,\n\t\t\tkeyframePairArr[i].inIndex\n\t\t);\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\treq.userVars.outEase[i] += deltaIncrement[i];\n\t\t}\n\t}\n\tapp.endUndoGroup();\n\treturn keyframePairArr.length\n\t\t? resObj\n\t\t: { success: false, data: null, message: notify.noKeyframes };\n}\n\n//TODO: finalize UI visualization logic for elastic/bounce\n//PROBLEM: elastic + bounce derive velocity from internal AE keyframe values\n//       - we expect users to apply elastic || bounce to more than a single layer\n//       - how do we choose which layer to derive velocity from?\nexport function getIncomingVelocity(): number {\n\treturn 1;\n};\n\n\nfunction sortShapesInShapeLayer(shapeLayerProps: ShapeLayer) {\n\tlet layerProperties = [];\n\tlet i = 0;\n\twhile (shapeLayerProps[i] !== undefined && shapeLayerProps[i].matchName !== \"ADBE Vector Group\") {\n\t\tlayerProperties.push(shapeLayerProps[i]);\n\t\ti++;\n\t}\n\tlayerProperties.sort((a, b) => { return a.propertyIndex - b.propertyIndex });\n\tlet shapeProperties = [];\n\tfor (let j = i; j < shapeLayerProps.length; j++) {\n\t\tif (shapeLayerProps[j].matchName === \"ADBE Vector Group\") {\n\t\t\tj++;\n\t\t\tlet shapePropArr = [];\n\t\t\tlet k = j;\n\t\t\twhile (shapeLayerProps[k] !== undefined && shapeLayerProps[k].matchName !== \"ADBE Vector Group\") {\n\t\t\t\tshapePropArr.push(shapeLayerProps[k]);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tshapePropArr.sort((a, b) => { return a.propertyIndex - b.propertyIndex });\n\t\t\tshapeProperties = shapeProperties.concat(shapePropArr);\n\t\t\tj = k - 1;\n\t\t}\n\t}\n\tlet res = shapeProperties.concat(layerProperties);\n\treturn res;\n}\n\n//We need to get selected layers and keyframes\n//TODO: Refactor, no need to traverse ALL selected properties twice.\nconst distributeEase = (req: ToolApplyRequest, comp: CompItem, layers: string | any[], resObj: ESResObjType) => {\n\n\tconst recurse = function (propertyGroup, keyframeArr) {\n\t\tlet selectedProps = []\n\t\tfor (let k = 0; k < propertyGroup.length; k++) {\n\t\t\tif (propertyGroup[k] === GROUP) recurse(prop, keyframeArr)\n\t\t\tselectedProps.push(propertyGroup[k])\n\t\t}\n\t\tkeyframeArr.push(selectedProps)\n\t}\n\n\tlet earliestFoundKeyframe = Infinity;\n\tlet keyframesInPropertyArr = [];\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar layerPropArray: _PropertyClasses[] = comp.layer(layers[i]['index']).selectedProperties\n\t\tif (layers[i].matchName === \"ADBE Vector Layer\") {\n\t\t\tlayerPropArray = sortShapesInShapeLayer(layerPropArray)\n\t\t} else {\n\t\t\tlayerPropArray = layerPropArray.sort((a, b) => { return a.propertyIndex - b.propertyIndex })\n\t\t}\n\t\tfor (let j = 0; j < layerPropArray.length; j++) {\n\t\t\tlet currProperty = layerPropArray[j] as Property<UnknownPropertyType>;\n\t\t\tif (currProperty instanceof PropertyGroup || currProperty instanceof MaskPropertyGroup) continue;\n\t\t\tlet selectedKeyframes = validateSelectedKeyframesDistribute(layerPropArray[j]);\n\t\t\tif (selectedKeyframes.length) {\n\t\t\t\tfoundKeyframe = true;\n\t\t\t\tif (currProperty.keyTime(selectedKeyframes[0]) < earliestFoundKeyframe) earliestFoundKeyframe = currProperty.keyTime(selectedKeyframes[0]);\n\t\t\t\tkeyframesInPropertyArr.push({\n\t\t\t\t\tproperty: currProperty,\n\t\t\t\t\tkeyframes: selectedKeyframes\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\tapp.beginUndoGroup('Distribute Keyframes')\n\tif (keyframesInPropertyArr.length === 1) {\n\t\t// alert(notify.pleaseSelectOneOrMoreKeyframes);\n\t\tresObj = { success: false, data: null, message: notify.pleaseSelectOneOrMoreKeyframes }\n\t\treturn resObj;\n\t} else if (keyframesInPropertyArr.length) {\n\t\tdistributeKeyframesAlongBezier(req, comp, layers, earliestFoundKeyframe, keyframesInPropertyArr);\n\t} else {\n\t\tdistributeLayersAlongBezier(req);\n\t}\n\tapp.endUndoGroup();\n\treturn resObj;\n}\n\nconst distributeLayersAlongBezier = (req: ToolApplyRequest) => {\n\t//@ts-ignore\n\tlet values: [] = req.values;\n\t//@ts-ignore\n\tvalues = mapPolyfill(values, function (x) { return 1 - x; });\n\tconst { numFrames } = req.userVars;\n\tconst layerArr = getSelectedLayerTimes()\n\tif (layerArr.length <= 1) {\n\t\t// alert(notify.insufficientLayers);\n\t\tresObj = { success: false, data: null, message: notify.insufficientLayers }\n\t\treturn resObj;\n\t}\n\tlet earliestLayerStartTime = Infinity;\n\tfor (let i = 0; i < layerArr.length; i++) {\n\t\tif (layerArr[i].time < earliestLayerStartTime) {\n\t\t\tearliestLayerStartTime = layerArr[i].time\n\t\t}\n\t}\n\t//@ts-ignore\n\tconst sortedLayerArr = layerArr.sort((a, b) => a.index - b.index)\n\t//@ts-ignore\n\tconst easing = bezier(values[0], values[1], values[2], values[3]); //returns function that gives X for a range\n\tconst mapping = rangeMap([1, sortedLayerArr.length], [0, 1]) //returns function that maps val in first range to second\n\tconst layers = enumFromTo(1, sortedLayerArr.length)   //creates array of numbers from 1 to layerArr.length\n\tlet rangeMappedLayers = mapEasing(mapping, layers) // 0 indexed, applies mapping function to each in layers\n\tlet updatedStartTimes: number[] = []\n\tfor (var i = 0; i < rangeMappedLayers.length; i++) {\n\t\tupdatedStartTimes[i] = easing(rangeMappedLayers[i]) * numFrames\n\t\tupdatedStartTimes[i] += earliestLayerStartTime * sortedLayerArr[0].frameRate\n\t}\n\tif (!req.userVars.isInverted) updatedStartTimes = updatedStartTimes.reverse()\n\tmoveLayers(updatedStartTimes, sortedLayerArr);\n}\n\nconst distributeKeyframesAlongBezier = (\n\treq: ToolApplyRequest,\n\tcomp: CompItem,\n\tlayers: string | any[],\n\tearliestFoundKeyframe: number,\n\tkeyframesInPropertyArr: number\n) => {\n\tlet values = validateCubicBezierX(req.values);\n\t//@ts-ignore\n\tconst easing = bezier(1-values[0], 1-values[1], 1-values[2], 1-values[3]);\n\tconst mapping = rangeMap([1, keyframesInPropertyArr.length], [0, 1]);\n\tconst layersArr = enumFromTo(1, keyframesInPropertyArr.length);\n\tlet rangeMappedLayers = mapEasing(mapping, layersArr);\n\tlet updatedStartTimes: number[] = [];\n\tfor (var i = 0; i < rangeMappedLayers.length; i++) {\n\t\tupdatedStartTimes[i] =\n\t\t\teasing(rangeMappedLayers[i]) * req.userVars.numFrames;\n\t}\n\tif (!req.userVars.isInverted) updatedStartTimes = updatedStartTimes.reverse();\n\tfor (let i = 0; i < keyframesInPropertyArr.length; i++) {\n\t\tfor (\n\t\t\tlet j = keyframesInPropertyArr[i][\"keyframes\"].length - 1;\n\t\t\tj >= 0;\n\t\t\tj--\n\t\t) {\n\t\t\tshiftKeyToNewOffset(\n\t\t\t\tkeyframesInPropertyArr[i].property,\n\t\t\t\tkeyframesInPropertyArr[i][\"keyframes\"][j],\n\t\t\t\tupdatedStartTimes[i] * comp.frameDuration,\n\t\t\t\tkeyframesInPropertyArr[i][\"keyframes\"][j]\n\t\t\t);\n\t\t}\n\t}\n};\n\nconst bezierEase = (\n\treq: ToolApplyRequest,\n\tcomp: CompItem,\n\tlayers: string | any[],\n\tresObj: ESResObjType\n) => {\n\tapp.beginUndoGroup(\"bezier ease\");\n\tlet success = false;\n\t//@ts-ignore\n\tconst values: [number, number, number, number] = validateCubicBezierX(\n\t\treq.values\n\t);\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar layerPropArray: _PropertyClasses[] = comp.layer(\n\t\t\tlayers[i][\"index\"]\n\t\t).selectedProperties;\n\t\tfor (let j = 0; j < layerPropArray.length; j++) {\n\t\t\tlet currProperty = layerPropArray[j] as Property<UnknownPropertyType>;\n\t\t\tif (\n\t\t\t\tcurrProperty instanceof PropertyGroup ||\n\t\t\t\tcurrProperty instanceof MaskPropertyGroup\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tlet selectedIndices = validateSelectedKeyframes(layerPropArray[j]);\n\t\t\tif (selectedIndices.length === 0) {\n\t\t\t\t// alert(notify.noKeyframes);\n\t\t\t\tresObj = {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: notify.pleaseAddOneOrMoreKeyframes,\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t} else if (selectedIndices.length === 1 && currProperty.numKeys === 1) {\n\t\t\t\t//alert(notify.pleaseAddOneOrMoreKeyframes)\n\t\t\t\tresObj = {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: notify.pleaseAddOneOrMoreKeyframes,\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t} else if (selectedIndices.length === 1 && currProperty.numKeys >= 2) {\n\t\t\t\tapplyBezierToSingleSelection(currProperty, selectedIndices[0], values);\n\t\t\t\tsuccess = true;\n\t\t\t} else if (\n\t\t\t\tselectedIndices.length === 2 &&\n\t\t\t\tMath.abs(selectedIndices[0] - selectedIndices[1]) === 1\n\t\t\t) {\n\t\t\t\tapplyBezierBookends(\n\t\t\t\t\tcurrProperty,\n\t\t\t\t\tselectedIndices[0],\n\t\t\t\t\tselectedIndices[1],\n\t\t\t\t\tvalues\n\t\t\t\t);\n\t\t\t\tsuccess = true;\n\t\t\t} else {\n\t\t\t\tapplyBezierToMultipleSelections(currProperty, selectedIndices, values);\n\t\t\t\tsuccess = true;\n\t\t\t}\n\t\t}\n\t}\n\tapp.endUndoGroup();\n\treturn success\n\t\t? { success: true, message: notify.success, data: null }\n\t\t: resObj;\n};\n\nconst bounceEase = (\n\treq: ToolApplyRequest,\n\tcomp: CompItem,\n\tlayers: string | any[],\n\tresObj: ESResObjType\n) => {\n\tapp.beginUndoGroup(\"bounce ease\");\n\tlet keyframesToWrite = [];\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tvar props = comp.layer(layers[i][\"index\"]).selectedProperties;\n\t\tfor (let j = 0; j < props.length; j++) {\n\t\t\t//TODO: add validation for bounce + elastic\n\t\t\tlet selectedIndices = validateSelectedKeyframes(props[j]);\n\t\t\tif (selectedIndices.length > 1) {\n\t\t\t\tlet keyframes = bounceEaseLayer(req, comp, props[j], req.values);\n\t\t\t\tlet keyframeWriteReq = {\n\t\t\t\t\tprop: props[j],\n\t\t\t\t\tkeyframes: keyframes,\n\t\t\t\t\tselectedIndices: selectedIndices,\n\t\t\t\t};\n\t\t\t\tkeyframesToWrite.push(keyframeWriteReq);\n\t\t\t}\n\t\t}\n\t}\n\tfor (let k = 0; k < keyframesToWrite.length; k++) {\n\t\tif (req.config.keyframeCollisionBehavior == \"overwrite\") {\n\t\t\tcreateBounceKeyframesOverwrite(\n\t\t\t\treq,\n\t\t\t\tcomp,\n\t\t\t\tkeyframesToWrite[k].prop,\n\t\t\t\tkeyframesToWrite[k].selectedIndices,\n\t\t\t\tkeyframesToWrite[k].keyframes\n\t\t\t);\n\t\t} else if (req.config.keyframeCollisionBehavior == \"stop\") {\n\t\t\tcreateBounceKeyframesStop(\n\t\t\t\treq,\n\t\t\t\tcomp,\n\t\t\t\tkeyframesToWrite[k].prop,\n\t\t\t\tkeyframesToWrite[k].selectedIndices,\n\t\t\t\tkeyframesToWrite[k].keyframes\n\t\t\t);\n\t\t}\n\t}\n\tapp.endUndoGroup();\n\treturn keyframesToWrite.length\n\t\t? resObj\n\t\t: {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: notify.pleaseSelectOneOrMoreKeyframes,\n\t\t\t\tdata: null,\n\t\t  };\n};\n\nconst elasticEase = (\n\treq: ToolApplyRequest,\n\tcomp: CompItem,\n\tlayers: string | any[],\n\tresObj: ESResObjType\n) => {\n\tapp.beginUndoGroup(\"Lazy Layers\");\n\tlet keyframesToWrite = [];\n\tfor (let i = 0; i < layers.length; i++) {\n\t\tlet layer = comp.layer(layers[i][\"index\"]);\n\t\tvar props = layer.selectedProperties;\n\t\tfor (let j = 0; j < props.length; j++) {\n\t\t\tlet selectedIndices = validateSelectedKeyframes(props[j]);\n\t\t\tif (selectedIndices.length > 1) {\n\t\t\t\tlet keysframes = elasticEaseLayer(props[j], req, selectedIndices);\n\t\t\t\tlet keyframeWriteReq = {\n\t\t\t\t\tprop: props[j],\n\t\t\t\t\tkeyframes: keysframes,\n\t\t\t\t\tselectedIndices: selectedIndices,\n\t\t\t\t};\n\t\t\t\tkeyframesToWrite.push(keyframeWriteReq);\n\t\t\t}\n\t\t}\n\t}\n\tfor (let k = 0; k < keyframesToWrite.length; k++) {\n\t\tif (req.config.keyframeCollisionBehavior == \"overwrite\") {\n\t\t\tcreateElasticKeyframesOverwrite(\n\t\t\t\treq,\n\t\t\t\tcomp,\n\t\t\t\tkeyframesToWrite[k].prop,\n\t\t\t\tkeyframesToWrite[k].selectedIndices,\n\t\t\t\tkeyframesToWrite[k].keyframes\n\t\t\t);\n\t\t} else if (req.config.keyframeCollisionBehavior == \"stop\") {\n\t\t\tcreateElasticKeyframesStop(\n\t\t\t\treq,\n\t\t\t\tcomp,\n\t\t\t\tkeyframesToWrite[k].prop,\n\t\t\t\tkeyframesToWrite[k].selectedIndices,\n\t\t\t\tkeyframesToWrite[k].keyframes\n\t\t\t);\n\t\t}\n\t}\n\tapp.endUndoGroup();\n\treturn keyframesToWrite.length\n\t\t? resObj\n\t\t: {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: notify.pleaseSelectOneOrMoreKeyframes,\n\t\t\t\tdata: null,\n\t\t  };\n};\n\nif (!String.prototype.includes) {\n\tString.prototype.includes = function (search, start) {\n\t\t\"use strict\";\n\t\tif (typeof start !== \"number\") {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (start + search.length > this.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.indexOf(search, start) !== -1;\n\t\t}\n\t};\n}\n","export const helloWorld = () => {\n  alert(\"Hello from Illustrator\");\n  app.activeDocument.path;\n};\n","export const helloWorld = () => {\n  alert(\"Hello from Animate\");\n  document.path;\n};\n","export const qeDomFunction = () => {\n  if (typeof qe === \"undefined\") {\n    app.enableQE();\n  }\n  if (qe) {\n    qe.name;\n    qe.project.getVideoEffectByName(\"test\");\n  }\n};\n\nexport const helloWorld = () => {\n  alert(\"Hello from Premiere Pro.\");\n};\n","export const helloWorld = () => {\n  app.activeDocument;\n  alert(\"Hello from Photoshop\");\n};\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as aeft from \"./aeft/aeft\";\nimport * as ilst from \"./ilst/ilst\";\nimport * as anim from \"./anim/anim\";\nimport * as ppro from \"./ppro/ppro\";\nimport * as phxs from \"./phxs/phxs\";\n\nlet main: any;\n\nswitch (BridgeTalk.appName) {\n  case \"premierepro\":\n  case \"premiereprobeta\":\n    main = ppro;\n    break;\n  case \"aftereffects\":\n  case \"aftereffectsbeta\":\n    main = aeft;\n    break;\n  case \"illustrator\":\n  case \"illustratorbeta\":\n    main = ilst;\n    break;\n  case \"photoshop\":\n  case \"photoshopbeta\":\n    main = phxs;\n    break;\n  default:\n    //@ts-ignore\n    if (app.appName === \"Adobe Animate\") {\n      main = anim;\n    }\n    break;\n}\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\nhost[ns] = main;\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","res","x1","y1","x2","y2","easeIn","easeOut","prop","applyBezierBookends","keyTemporalAutoBezier","keyTemporalContinuous","keyInTemporalEase","keyOutTemporalEase","keySpatialAutoBezier","keySpatialContinuous","keyInSpatialTangent","keyOutSpatialTangent","keyRoving","keyInInterpolationType","keyOutInterpolationType","curKeyValue","setKeyValues","noComp","noLayer","noKeyframes","insufficientLayers","pleaseAddOneOrMoreKeyframes","pleaseSelectOneOrMoreKeyframes","elasticNoDelta","maskPath","alert","clearAllSpatialEaseOnKeyframe","peakKfValue","dstKfValue","peakKfTimeOffset","dstKfTimeOffset","cubicBez","keysframesToWrite","firstExistingKeyframeTime","peakKeyframeWriteTime","dstKeyframeWriteTime","applyBezierToPeak","a1","a2","b1","b2","arr","result","i","aB","aA","sampleValues","intervalStart","index","time","frameRate","obj","selectedLayerTimes","valueLerpMax","key","plan","last_check","License","saveSetting","app","lastKey","interpolationType","duration","len","averageSpeed","infOut","infIn","bezierIn","bezierOut","out","curveSegments","lastPoint","addedLength","point","perc","ptDistance","absToCoord","absTiCoord","outBezier","triCoord1","triCoord2","triCoord3","influence","speed","inEase","T","k","kValue","A","mappedValue","success","data","message","generalInputValidation","x","y","layerPropArray","property","outIndex","deltasArr","updatedStartTimes","shiftKeyToNewOffset","layerProperties","j","shapePropArr","shapeProperties","foundKeyframe","keyframes","resObj","values","earliestLayerStartTime","moveLayers","applyBezierToMultipleSelections","selectedIndices","keyframesToWrite","start","qe","main","host"],"mappings":";;AAGA;AACCA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEEC;AACAV;AACD;AAGDW;AACAC;AACAC;AACAC;AACAC;AACA;;AAEAC;AACAC;AAEAC;AAEEC;AACAT;AACAU;AACAC;AACAL;AACAC;AACD;AAECE;AACAT;AACAC;AACA;AACAU;AACAL;AACAC;AACD;AAEDK;AACCC;AACAC;;AAEDC;AACCC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEDQ;AACAC;AACAC;AACD;;AChEA;;ACsEA;;AAEA;AA0DA;;;AAGM;;AAEA;AACA;AACF;;AAEA;AACF;AAEF;;;AAGM;AACEC;AACF;AACA;AACF;;AAEA;AACF;;;;;;;;ACxJA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AAAMC;AAAIC;AAAIC;AAAIC;;;AAGlB;AACA;;;AAGI;AACA;AACA;AACA;AACA;;;AAGIC;AACJ;;AAGJ;;AAEI;AACA;AACA;AACA;;;;AAII;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACA;;;;AAIIC;AACAD;AACJ;AACIA;AACAC;AACJ;;AAEJ;AACA;AACI;;;AAGA;AACJ;;AAEA;AACJ;AACR;AAEA;AACI;AACA;AACA;AACJ;AAEA;AACI;AAAML;AAAIC;AAAIC;AAAIC;;;AAGlB;AACA;;;AAGI;AACA;AACA;AACA;;;AAGIE;AACJ;;AAGJ;;AAGI;AACA;AACA;AACA;;;;AAKI;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACA;;;;AAIIA;AACAD;AACJ;AACIA;AACAC;AACJ;;AAEJ;AACA;AACI;;;AAGA;AACJ;;AAEA;AACJ;AACR;AAGA;AACQ;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAGR;AAGA;;AAEQ;AACA;;AAEA;AACA;;AAEA;AACIC;AACJ;AACIA;AACJ;AACJ;AACI;AACA;;AAEA;AACA;;AAGA;AACIA;AACJ;AACIA;AACJ;AACJ;AACI;;AAEA;;AAEJ;AACJ;AAEA;AACIC;AACA;;AAEA;AACJ;;AAEA;AACA;AACI;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAGA;AACID;AACJ;AACIA;AACJ;AACA;AACIA;AACJ;AACIA;AACJ;AAEJ;;ACzNA;;;AAGM;AACF;AACA;AACF;;ACJF;AACI;;;;AAGA;AACJ;AAaA;AACE;;;AAGEA;AACF;AACF;AAEA;AACE;AACA;AACA;;AAEA;AACA;AACF;AAiCA;AACE;AACA;AACA;;;AAIEE;AACAC;AACF;;AAGA;AACEC;AACAC;AACF;;AAGA;AAIEC;AACAC;AACAC;AACAC;AACAC;AACF;;AAESC;AAAwBC;AAAyBC;AAAaX;AACrEC;AAAuBC;AAAmBC;AAC1CC;AAAsBC;AAAsBC;AAAqBC;AAAsBC;;AAC3F;AAEA;;;AAIIV;AAEF;;;AAOA;AAEA;;;AAMEA;AACA;AACF;AACF;AAkJA;;AAEE;;AAEA;AACAc;AACAd;AACF;;ACtRA;AACIe;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACJ;;ACPA;;AAKEC;AACA;AACD;AACA;AACCA;AACA;AACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACC;AACA;AACC;AACA;AACD;;;;AAKC;AACA;AACD;AACC;AACA;AACD;AACC;AAICC;AACAA;AACD;AACA;AACD;AACD;AAEA;AACC;AACA;AACC;AACA;AACD;;;;AAKC;AACA;AACD;AACC;AACA;AACD;AACC;AACD;AACD;;AAEA;AACA;AACC;AACA;AACA;AACA;AACA;AACD;;AClEA;AACC;;;AAGA;AACA;AACA;;AAIA;AACC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAIA;;;AAGEC;AACD;AACCC;AACD;AACD;;AAEA;AACA;AAMA;AACCC;AACAC;AACAH;AACAC;AACAG;;AAEDC;AACD;AACA;AACD;;AAEA;AACA;AAOC;;AAEA;AAGA;AAGA;AACA;AACC;;AAECC;AACA;AACA;AAICP;AACA;AACA;AACD;AACD;AACD;AAEA;AACC;;;;;;AAQA;AACA;AACA;AACCQ;AACAC;;AAED;;AAGC;AACA;AACA;AACAjC;AACA;AACA;AACA;AACAA;AACA;;;;;;;;;AAiBA;AACCkC;AAMD;AACD;AACD;;AAED;AAEA;AAOC;AAGA;AAGA;AAIA;AACC;AAIClC;AACD;AACD;AAEA;AACC;;;;;;AAQA;AACA;AACA;AACCgC;AACAC;;AAED;AAEA;AACA;AACAjC;AACA;AACA;AACA;AACAA;AACA;;;;;;;;;AASA;AACCkC;AAMD;AACD;;AAED;;;;;;;;ACjOA;;AACE;AAAOC;AAAIC;AACX;AAAOC;AAAIC;AACX;AACA;;;AAED;;AAED;AACA;;;AAGIC;AACF;AACA;AACF;AAEA;AAA2C;AAAuB;AAElE;;AAEE;AACEC;AACF;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAmE;AACnE;AAAmC;AAA0B;AAC7D;;AAAoC;;AAEpC;AACA;;AAEA;;AAEA;AACA;;AAEA;AAEA;AACE;;AAEEC;;;;;AAKEC;AACF;AACEC;AACF;AACF;AACA;AACF;AAEA;;;;AAIM;AACF;;;AAGF;AACA;AACF;AAEA;AACE;AACF;AAEA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACF;;AAEA;AACA;;AAEEC;AACF;AAEA;;;AAGE;AAEA;AACEC;AACF;AACA;;AAEA;;AAEA;;;;AAKA;AACE;AACF;AACE;AACF;;;AAIA;AACA;AACE;AACF;;;AAGJ;;ACvIA;AACA;;;;AAIQ;AACI;AAAYC;AAAUC;AAASC;;;;AAG/BC;AACAC;AACJ;AACJ;AACA;AACJ;AACA;AACA;AACA;AACI;AACA;AACI;AACI;;AAEJ;AACJ;AACJ;AAEA;;;AAGI;AACJ;;ACbA;AACE;;;AAGA;AACA;AAEA;AACA;;;AAGIC;AACF;AACF;;AAEA;;AAEE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACExB;AACAF;AACAC;AACAE;AACAC;;AAEFC;AACA;AACA;AACA;AACA;AACF;;AACA;AACF;AAEA;AACE;AACA;AACA;AAEA;AACE;AACE9B;AACF;AACF;AAEA;AACE;;;;;;AAKE;AACA;AACA;AAEEgC;AACAC;;AAEF;AACA;AACA;AACA;AACAjC;AACA;AACA;AACA;AACAA;AACAkC;AACJ;AACF;AAEA;;AAEE;AACA;AAEA;AACE;;AAEIH;AACA;AACA;AACEP;AACA;AACF;AACA;AACJ;AACF;AAEA;AACE;;;;;;AAME;AACA;AACA;AAEEQ;AACAC;;AAEF;;AAGE;AACA;AACA;AACAjC;AACA;AACA;AACA;AACAA;AACAkC;AACJ;AACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;;AAEC;AACCkB;AACAC;AACAC;;;AAIA;AACA;AACD;;;AAIA;AAGAC;AAAYH;AAAKC;AAAMC;;AACvB;AACA;AACD;AAEA;;AAECE;AACAA;AACAC;AACD;AAEA;;AAECA;AACD;;AC/BA;;;;;;;AAQIL;AACAM;AACA;AACIN;AACAM;AACJ;;AAEIC;AACJ;;AAEQA;AACJ;;;;;;;AAOQ;AACR;AACJ;AAIAC;AACAC;;;AAGAC;;;;;AAKQ;;;AAGIC;AACAC;AACJ;;;AAGA;AACAC;AACAC;AACA;;AAEAJ;AACAC;AACAC;AACAC;AACAC;AACA;;;;;;;;AAQID;AACAC;AAEJ;AACAJ;;AAEIA;AACJ;AACA;AACR;;AAEIG;AACAC;AACJ;;;;;;AAMgBD;AACAC;AACJ;AACID;AACAC;AACJ;AACA;;;;;;;;;;;AAWI;;;AAGA;AACJ;AACJ;AACR;;AACQ;AAAaC;AAAcP;;AACvC;AAEA;AACI;AAAOQ;AACP;AAAUC;AACV;;AAEA;;;;;;;AAAiEC;;AAE7DC;AACAC;AACAC;AACAC;AACAC;AACAC;AACI;AACIF;AACAC;AACJ;AACAE;AACAC;AACAC;;;;AAIAR;;AAEIE;AACJ;AACJ;AACAA;AACAH;AACAD;AACJ;AACA;AACJ;AAGA;;;;;;AAMgBW;AACAC;;;;;;AAMJ;AACJ;;;;AAII;AACAC;AACI9B;;;AAA6D;AAC7DM;AAAsBsB;AAAsCC;AAA0B;AAC1F;AACR;AACJ;AAEA;AACI;AAEI;AACI;AAEJ;AACI;AAER;AACJ;AAEA;;;;AAIY;AACJ;AACA;AACA;AACA;AACI;AACJ;AACA;AACIE;AACJ;AACAC;;AAEI;;AAEIC;;AAEJ;AACAD;AACJ;;AAER;AACA;;AAGQ;;AAGI;AACJ;AACA;AACA;AACA;AACI;AACJ;AACA;AACID;AACJ;AACAG;AACAF;;;;AAIQC;AACAE;AACAD;AACJ;AACAF;AACJ;AAEA;;AAER;;AC5MA;AACC;AACCI;AACAC;AACAC;;AAED;AACA;;;;;;;AAaA;AAEEF;;AAEAE;AACD;AACDC;;AAGC;;AAEC;AACD;;AAEC;AACD;;AAEC;AACD;;AAEC;AACD;;AAEC;AAGF;AACA;AACD;AAEA;AACClC;AACA;AACA;AACA;AACA;AACC;AAGA;AACC;AACA;AAEA;AACA;AACCzD;AAKD;AACD;AACD;;AAED;AAEA;AACC;AACA;AACA;AACA;AACA;AACC;AAGA;AACC;AACA;AAEA;AACA;;;AAMC;AACD;;AAKC;AACA;;AACO4F;AAAuBC;;AAC7B1B;AAAOyB;AAAuBC;;AAC9BjC;AACA4B;;AAED;;AAMA;;AAEA;;AACOI;AAAsBC;;AAC5B1B;AAAOyB;AAAwBC;;AAC/BjC;AACA4B;;AAED;AACD;AACD;AACD;;AAECA;;AAEAE;AACD;AACD;AAEA;AACCjC;AACAA;AACAA;AACA;AACD;AAEA;;;AAGE;AACD;;AAEC;AACD;AACD;AAEA;AACCA;AAKAA;AACAA;AACA;AACD;AAEA;AACC;;AAKC;AACD;AACC;AAIA;AACD;AACD;AAEA;AACCA;AAKAA;AACAA;AACA;AACD;AAEA;;;AAGE;AACD;;AAKC;AACD;AACD;AAEA;;;AAIC;AACC;;AAECqC;AACD;;AACkD;AAAyC;AAC3F;AACA;AACC;AACA;;AAEA;;;AASEC;;AAEAC;AACD;AACD;AACD;AACD;;;;;AAKCC;AACD;;;;AAIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACCC;AACD;AACA;AAEAzC;AACA;AACCxD;AAMAkG;AAMAA;;;AAQA;AACD;;AAEA;AAEKX;AAAgBC;;;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACC;AACD;AAGA;;;AAGC;AACCW;AACA3D;AACD;AACA2D;AAAiC;AAAyC;;AAE1E;;AAEEC;;;AAGA;AACCC;AACAlB;AACD;AACAkB;AAA8B;AAAyC;AACvEC;;AAED;AACD;AACA;AACA;AACD;;AAEA;AACA;AACA;;;AAaC;AACC;;AAECT;AACD;;AACkD;AAAyC;AAC3F;AACA;AACC;AACA;;;AAGCU;;;AAGCT;AACAU;AACD;AACD;AACD;AACD;AACAhD;AACA;AACC;AACAiD;AAAWlB;AAAgBC;;;AAC3B;AACD;;AAEA;;AAEA;;AAEA;AACD;AAEA;AACC;AACA;AACA;AACAkB;;AAA0D;AAC1D;AACA;AACA;AACC;AACAD;AAAWlB;AAAgBC;;;AAC3B;AACD;;AAEA;;AAEEmB;AACD;AACD;AACA;;AAC0C;;AAC1C;;AAEA;;;;AAIA;AACCV;;AAED;AACA;AACAW;AACD;AAEA;AAOC;AACA;AACA;AACA;;AAEA;;AAEA;AACCX;AAED;AACA;AACA;;AAMEC;AAMD;AACD;AACD;AAEA;AAMC1C;;AAEA;AACA;AAGA;AACC;AAGA;AACC;AACA;;AAMA;AACC;AACAiD;AACClB;;AAEAC;;AAEF;AACC;AACAiB;AACClB;;AAEAC;;AAEF;;AAECD;;AAKAvF;AAMAuF;AACD;AACCsB;AACAtB;AACD;AACD;AACD;;AAEA;AACKA;;AAAwCC;AAAW;AAEzD;AAEA;AAMChC;;AAEA;AACC;AACA;AACC;;AAEA;AACC;AACA;AACCzD;AACAyG;AACAM;;AAEDC;AACD;AACD;AACD;AACA;AACC;;;;AAgBA;AACD;;AAEA;AAGGxB;;AAEAC;;AAEJ;AAEA;AAMChC;;AAEA;AACC;AACA;AACA;;AAEC;AACC;AACA;AACCzD;AACAyG;AACAM;;AAEDC;AACD;AACD;AACD;AACA;AACC;;;;AAgBA;AACD;;AAEA;AAGGxB;;AAEAC;;AAEJ;AAEA;;;AAGE;AACCwB;AACD;;AAGC;AACD;;AAEA;;AAEF;;;;;;;;;;;;;;;;;;ACvpBA;;;AAGA;;;;;;;ACHA;;AAGA;;;;;;;ACHA;AACE;;AAEA;AACA;AACEC;AACAA;AACF;AACF;AAEA;;AAEA;;;;;;;;ACZA;AACEzD;;AAEF;;;;;;;ACOA;AAEA;AACE;AACA;AACE0D;AACA;AACF;AACA;AACEA;AACA;AACF;AACA;AACEA;AACA;AACF;AACA;AACEA;AACA;AACF;AACE;AACA;AACEA;AACF;AACA;AACJ;AACA;AACA;AACAC"}